{"version":3,"file":"static/js/361.0fbdb38c.chunk.js","mappings":"4GAAAA,EAAOC,QAAU,EAAjB,O,qBCAA,OAMC,SAAWC,GACV,aACA,IAAIC,EAyBFC,EAAS,IAGTC,EAAY,IA4BZC,EAAO,YACPC,EAAUD,EAAO,WACjBE,EAAaD,EAAU,iBAEvBE,EAAcH,EAAO,mBAGrBI,EAAI,GACJC,OAAY,EACZC,EAAU,uCA0HZ,SAASC,EAAMC,EAAGC,EAAIC,EAAIC,GACxB,IAAIC,EAAKJ,EAAEK,EAGX,GADIH,IAAOL,IAAWK,EAAKF,EAAEM,YAAYC,IAC9B,IAAPL,GAAmB,IAAPA,GAAmB,IAAPA,GAAmB,IAAPA,EACtC,MAAMM,MArIKf,kCAwIb,GAAIQ,EAAK,EACPE,EACS,IAAPD,IAAaC,KAAUC,EAAG,KAAc,IAAPH,IAC1B,IAAPC,GAAYE,EAAG,IAAM,GACd,IAAPF,IAAaE,EAAG,GAAK,GAAe,IAAVA,EAAG,KAAaD,GAAQC,EAAG,KAAOP,KAG9DO,EAAGK,OAAS,EAERN,GAGFH,EAAEU,EAAIV,EAAEU,EAAIT,EAAK,EACjBG,EAAG,GAAK,GAIRA,EAAG,GAAKJ,EAAEU,EAAI,OAEX,GAAIT,EAAKG,EAAGK,OAAQ,CAazB,GAVAN,EACS,IAAPD,GAAYE,EAAGH,IAAO,GACf,IAAPC,IAAaE,EAAGH,GAAM,GAAgB,IAAXG,EAAGH,KAC3BE,GAAQC,EAAGH,EAAK,KAAOJ,GAA0B,EAAbO,EAAGH,EAAK,MACxC,IAAPC,IAAaC,KAAUC,EAAG,IAG5BA,EAAGK,OAASR,IAGRE,EAGF,OAASC,EAAGH,GAAM,GAChBG,EAAGH,GAAM,EACJA,QACDD,EAAEU,EACJN,EAAGO,QAAQ,IAMjB,IAAKV,EAAKG,EAAGK,QAASL,IAAKH,IAAMG,EAAGQ,MAGtC,OAAOZ,EAQT,SAASa,EAAUb,EAAGc,EAAeC,GACnC,IAAIL,EAAIV,EAAEU,EACRM,EAAIhB,EAAEK,EAAEY,KAAK,IACbC,EAAIF,EAAEP,OAGR,GAAIK,EACFE,EAAIA,EAAEG,OAAO,IAAMD,EAAI,EAAI,IAAMF,EAAEI,MAAM,GAAK,KAAOV,EAAI,EAAI,IAAM,MAAQA,OAGtE,GAAIA,EAAI,EAAG,CAChB,OAASA,GAAIM,EAAI,IAAMA,EACvBA,EAAI,KAAOA,OACN,GAAIN,EAAI,EACb,KAAMA,EAAIQ,EACR,IAAKR,GAAKQ,EAAGR,KAAMM,GAAK,SACfN,EAAIQ,IACbF,EAAIA,EAAEI,MAAM,EAAGV,GAAK,IAAMM,EAAEI,MAAMV,SAE3BQ,EAAI,IACbF,EAAIA,EAAEG,OAAO,GAAK,IAAMH,EAAEI,MAAM,IAGlC,OAAOpB,EAAEgB,EAAI,GAAKD,EAAY,IAAMC,EAAIA,EAU1CpB,EAAEyB,IAAM,WACN,IAAIrB,EAAI,IAAIsB,KAAKhB,YAAYgB,MAE7B,OADAtB,EAAEgB,EAAI,EACChB,GASTJ,EAAE2B,IAAM,SAAUC,GAChB,IAAIC,EACFzB,EAAIsB,KACJlB,EAAKJ,EAAEK,EACPqB,GAAMF,EAAI,IAAIxB,EAAEM,YAAYkB,IAAInB,EAChCsB,EAAI3B,EAAEgB,EACNY,EAAIJ,EAAER,EACNa,EAAI7B,EAAEU,EACNoB,EAAIN,EAAEd,EAGR,IAAKN,EAAG,KAAOsB,EAAG,GAAI,OAAQtB,EAAG,GAAuBuB,EAAjBD,EAAG,IAAUE,EAAL,EAG/C,GAAID,GAAKC,EAAG,OAAOD,EAKnB,GAHAF,EAAQE,EAAI,EAGRE,GAAKC,EAAG,OAAOD,EAAIC,EAAIL,EAAQ,GAAK,EAKxC,IAHAG,GAAKC,EAAIzB,EAAGK,SAAWqB,EAAIJ,EAAGjB,QAAUoB,EAAIC,EAGvCH,GAAK,IAAKA,EAAIC,GACjB,GAAIxB,EAAGuB,IAAMD,EAAGC,GAAI,OAAOvB,EAAGuB,GAAKD,EAAGC,GAAKF,EAAQ,GAAK,EAI1D,OAAOI,GAAKC,EAAI,EAAID,EAAIC,EAAIL,EAAQ,GAAK,GAQ3C7B,EAAEmC,IAAM,SAAUP,GAChB,IAAIxB,EAAIsB,KACNjC,EAAMW,EAAEM,YACR0B,EAAIhC,EAAEK,EACN4B,GAAKT,EAAI,IAAInC,EAAImC,IAAInB,EACrBwB,EAAI7B,EAAEgB,GAAKQ,EAAER,EAAI,GAAK,EACtBkB,EAAK7C,EAAI8C,GAEX,GAAID,MAASA,GAAMA,EAAK,GAAKA,EAAK5C,EAChC,MAAMkB,MAAMd,GAId,IAAKuC,EAAE,GACL,MAAMzB,MAAMb,GAId,IAAKqC,EAAE,GAGL,OAFAR,EAAER,EAAIa,EACNL,EAAEnB,EAAI,CAACmB,EAAEd,EAAI,GACNc,EAGT,IAAIY,EAAIC,EAAInB,EAAGK,EAAKe,EAClBC,EAAKN,EAAEb,QACPoB,EAAKJ,EAAKH,EAAExB,OACZgC,EAAKT,EAAEvB,OACPiC,EAAIV,EAAEZ,MAAM,EAAGgB,GACfO,EAAKD,EAAEjC,OACPmC,EAAIpB,EACJqB,EAAKD,EAAEvC,EAAI,GACXyC,EAAK,EACLC,EAAIb,GAAMU,EAAElC,EAAIV,EAAEU,EAAIc,EAAEd,GAAK,EAS/B,IAPAkC,EAAE5B,EAAIa,EACNA,EAAIkB,EAAI,EAAI,EAAIA,EAGhBR,EAAG5B,QAAQ,GAGJgC,IAAOP,GAAKM,EAAEM,KAAK,GAE1B,EAAG,CAGD,IAAK9B,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAGvB,GAAIkB,IAAOO,EAAKD,EAAEjC,QAChBc,EAAMa,EAAKO,EAAK,GAAK,OAErB,IAAKL,GAAM,EAAGf,EAAM,IAAKe,EAAKF,GAC5B,GAAIH,EAAEK,IAAOI,EAAEJ,GAAK,CAClBf,EAAMU,EAAEK,GAAMI,EAAEJ,GAAM,GAAK,EAC3B,MAMN,KAAIf,EAAM,GAgBR,MAZA,IAAKc,EAAKM,GAAMP,EAAKH,EAAIM,EAAII,GAAK,CAChC,GAAID,IAAIC,GAAMN,EAAGM,GAAK,CAEpB,IADAL,EAAKK,EACEL,IAAOI,IAAIJ,IAAMI,EAAEJ,GAAM,IAC9BI,EAAEJ,GACJI,EAAEC,IAAO,GAEXD,EAAEC,IAAON,EAAGM,GAGd,MAAQD,EAAE,IAAKA,EAAEO,QAOrBJ,EAAGC,KAAQvB,EAAML,IAAMA,EAGnBwB,EAAE,IAAMnB,EAAKmB,EAAEC,GAAMX,EAAEQ,IAAO,EAC7BE,EAAI,CAACV,EAAEQ,WAEJA,IAAOC,GAAMC,EAAE,KAAO7C,IAAcgC,KAc9C,OAXKgB,EAAG,IAAY,GAANC,IAGZD,EAAGI,QACHL,EAAElC,IACFqC,KAIED,EAAKC,GAAGhD,EAAM6C,EAAGG,EAAG1D,EAAIkB,GAAImC,EAAE,KAAO7C,GAElC+C,GAOThD,EAAEsD,GAAK,SAAU1B,GACf,OAAuB,IAAhBF,KAAKC,IAAIC,IAQlB5B,EAAEuD,GAAK,SAAU3B,GACf,OAAOF,KAAKC,IAAIC,GAAK,GAQvB5B,EAAEwD,IAAM,SAAU5B,GAChB,OAAOF,KAAKC,IAAIC,IAAM,GAOxB5B,EAAEyD,GAAK,SAAU7B,GACf,OAAOF,KAAKC,IAAIC,GAAK,GAQvB5B,EAAE0D,IAAM,SAAU9B,GAChB,OAAOF,KAAKC,IAAIC,GAAK,GAOvB5B,EAAE2D,MAAQ3D,EAAE4D,IAAM,SAAUhC,GAC1B,IAAIG,EAAGC,EAAG6B,EAAGC,EACX1D,EAAIsB,KACJjC,EAAMW,EAAEM,YACR0B,EAAIhC,EAAEgB,EACNiB,GAAKT,EAAI,IAAInC,EAAImC,IAAIR,EAGvB,GAAIgB,GAAKC,EAEP,OADAT,EAAER,GAAKiB,EACAjC,EAAE2D,KAAKnC,GAGhB,IAAIpB,EAAKJ,EAAEK,EAAEe,QACXwC,EAAK5D,EAAEU,EACPgB,EAAKF,EAAEnB,EACPwD,EAAKrC,EAAEd,EAGT,IAAKN,EAAG,KAAOsB,EAAG,GAQhB,OAPIA,EAAG,GACLF,EAAER,GAAKiB,EACE7B,EAAG,GACZoB,EAAI,IAAInC,EAAIW,GAEZwB,EAAER,EAAI,EAEDQ,EAIT,GAAIQ,EAAI4B,EAAKC,EAAI,CAWf,KATIH,EAAO1B,EAAI,IACbA,GAAKA,EACLyB,EAAIrD,IAEJyD,EAAKD,EACLH,EAAI/B,GAGN+B,EAAEK,UACG7B,EAAID,EAAGC,KAAMwB,EAAET,KAAK,GACzBS,EAAEK,eAMF,IAFAlC,IAAM8B,EAAOtD,EAAGK,OAASiB,EAAGjB,QAAUL,EAAKsB,GAAIjB,OAE1CuB,EAAIC,EAAI,EAAGA,EAAIL,EAAGK,IACrB,GAAI7B,EAAG6B,IAAMP,EAAGO,GAAI,CAClByB,EAAOtD,EAAG6B,GAAKP,EAAGO,GAClB,MAiBN,GAXIyB,IACFD,EAAIrD,EACJA,EAAKsB,EACLA,EAAK+B,EACLjC,EAAER,GAAKQ,EAAER,IAONiB,GAAKL,EAAIF,EAAGjB,SAAWkB,EAAIvB,EAAGK,SAAW,EAAG,KAAOwB,KAAM7B,EAAGuB,KAAO,EAGxE,IAAKM,EAAIN,EAAGC,EAAII,GAAI,CAClB,GAAI5B,IAAKwB,GAAKF,EAAGE,GAAI,CACnB,IAAKD,EAAIC,EAAGD,IAAMvB,IAAKuB,IAAKvB,EAAGuB,GAAK,IAClCvB,EAAGuB,GACLvB,EAAGwB,IAAM,GAGXxB,EAAGwB,IAAMF,EAAGE,GAId,KAAmB,IAAZxB,IAAK6B,IAAW7B,EAAGQ,MAG1B,KAAiB,IAAVR,EAAG,IACRA,EAAG6C,UACDY,EAeJ,OAZKzD,EAAG,KAGNoB,EAAER,EAAI,EAGNZ,EAAK,CAACyD,EAAK,IAGbrC,EAAEnB,EAAID,EACNoB,EAAEd,EAAImD,EAECrC,GAOT5B,EAAEmE,IAAM,SAAUvC,GAChB,IAAIwC,EACFhE,EAAIsB,KACJjC,EAAMW,EAAEM,YACR0B,EAAIhC,EAAEgB,EACNiB,GAAKT,EAAI,IAAInC,EAAImC,IAAIR,EAEvB,IAAKQ,EAAEnB,EAAE,GACP,MAAMG,MAAMb,GAQd,OALAK,EAAEgB,EAAIQ,EAAER,EAAI,EACZgD,EAAmB,GAAZxC,EAAED,IAAIvB,GACbA,EAAEgB,EAAIgB,EACNR,EAAER,EAAIiB,EAEF+B,EAAa,IAAI3E,EAAIW,IAEzBgC,EAAI3C,EAAI8C,GACRF,EAAI5C,EAAIkB,GACRlB,EAAI8C,GAAK9C,EAAIkB,GAAK,EAClBP,EAAIA,EAAE+B,IAAIP,GACVnC,EAAI8C,GAAKH,EACT3C,EAAIkB,GAAK0B,EAEFX,KAAKiC,MAAMvD,EAAEiE,MAAMzC,MAO5B5B,EAAE+D,KAAO/D,EAAEsE,IAAM,SAAU1C,GACzB,IAAId,EAAGmB,EAAG4B,EACRzD,EAAIsB,KACJjC,EAAMW,EAAEM,YAKV,GAHAkB,EAAI,IAAInC,EAAImC,GAGRxB,EAAEgB,GAAKQ,EAAER,EAEX,OADAQ,EAAER,GAAKQ,EAAER,EACFhB,EAAEuD,MAAM/B,GAGjB,IAAIoC,EAAK5D,EAAEU,EACTN,EAAKJ,EAAEK,EACPwD,EAAKrC,EAAEd,EACPgB,EAAKF,EAAEnB,EAGT,IAAKD,EAAG,KAAOsB,EAAG,GAQhB,OAPKA,EAAG,KACFtB,EAAG,GACLoB,EAAI,IAAInC,EAAIW,GAEZwB,EAAER,EAAIhB,EAAEgB,GAGLQ,EAOT,GAJApB,EAAKA,EAAGgB,QAIJV,EAAIkD,EAAKC,EAAI,CAUf,IATInD,EAAI,GACNmD,EAAKD,EACLH,EAAI/B,IAEJhB,GAAKA,EACL+C,EAAIrD,GAGNqD,EAAEK,UACKpD,KAAM+C,EAAET,KAAK,GACpBS,EAAEK,UAaJ,IATI1D,EAAGK,OAASiB,EAAGjB,OAAS,IAC1BgD,EAAI/B,EACJA,EAAKtB,EACLA,EAAKqD,GAGP/C,EAAIgB,EAAGjB,OAGFoB,EAAI,EAAGnB,EAAGN,EAAGM,IAAM,GAAImB,GAAKzB,IAAKM,GAAKN,EAAGM,GAAKgB,EAAGhB,GAAKmB,GAAK,GAAK,EAUrE,IANIA,IACFzB,EAAGO,QAAQkB,KACTgC,GAICnD,EAAIN,EAAGK,OAAoB,IAAZL,IAAKM,IAAWN,EAAGQ,MAKvC,OAHAY,EAAEnB,EAAID,EACNoB,EAAEd,EAAImD,EAECrC,GAWT5B,EAAEuE,IAAM,SAAUjD,GAChB,IAAIlB,EAAIsB,KACN8C,EAAM,IAAIpE,EAAEM,YAAY,KACxBkB,EAAI4C,EACJ3C,EAAQP,EAAI,EAEd,GAAIA,MAAQA,GAAKA,GAAI,KAAcA,EAAI3B,EACrC,MAAMiB,MAAMf,EAAU,YAKxB,IAFIgC,IAAOP,GAAKA,GAGN,EAAJA,IAAOM,EAAIA,EAAEyC,MAAMjE,IACvBkB,IAAM,GAENlB,EAAIA,EAAEiE,MAAMjE,GAGd,OAAOyB,EAAQ2C,EAAIrC,IAAIP,GAAKA,GAW9B5B,EAAEyE,KAAO,SAAUpE,EAAIC,GACrB,GAAID,MAASA,GAAMA,EAAK,GAAKA,EAAKX,EAChC,MAAMkB,MAAMf,EAAU,aAExB,OAAOM,EAAM,IAAIuB,KAAKhB,YAAYgB,MAAOrB,EAAIC,IAa/CN,EAAEG,MAAQ,SAAUmC,EAAIhC,GACtB,GAAIgC,IAAOrC,EAAWqC,EAAK,OACtB,GAAIA,MAASA,GAAMA,GAAM5C,GAAU4C,EAAK5C,EAC3C,MAAMkB,MAAMd,GAEd,OAAOK,EAAM,IAAIuB,KAAKhB,YAAYgB,MAAOY,EAAKZ,KAAKZ,EAAI,EAAGR,IAQ5DN,EAAE0E,KAAO,WACP,IAAI5B,EAAGrC,EAAGoD,EACRzD,EAAIsB,KACJjC,EAAMW,EAAEM,YACRU,EAAIhB,EAAEgB,EACNN,EAAIV,EAAEU,EACN6D,EAAO,IAAIlF,EAAI,OAGjB,IAAKW,EAAEK,EAAE,GAAI,OAAO,IAAIhB,EAAIW,GAG5B,GAAIgB,EAAI,EACN,MAAMR,MAAMhB,EAAO,kBAQX,KAJVwB,EAAIwD,KAAKF,KAAKtE,EAAI,MAIHgB,IAAM,MACnBX,EAAIL,EAAEK,EAAEY,KAAK,KACLR,OAASC,EAAI,IAAIL,GAAK,KAE9BK,IAAMA,EAAI,GAAK,EAAI,IAAMA,EAAI,GAAS,EAAJA,GAClCgC,EAAI,IAAIrD,IAFR2B,EAAIwD,KAAKF,KAAKjE,KAEI,IAAQ,MAAQW,EAAIA,EAAEyD,iBAAiBrD,MAAM,EAAGJ,EAAE0D,QAAQ,KAAO,IAAMhE,IAEzFgC,EAAI,IAAIrD,EAAI2B,EAAI,IAGlBN,EAAIgC,EAAEhC,GAAKrB,EAAI8C,IAAM,GAGrB,GACEsB,EAAIf,EACJA,EAAI6B,EAAKN,MAAMR,EAAEE,KAAK3D,EAAE+B,IAAI0B,WACrBA,EAAEpD,EAAEe,MAAM,EAAGV,GAAGO,KAAK,MAAQyB,EAAErC,EAAEe,MAAM,EAAGV,GAAGO,KAAK,KAE3D,OAAOlB,EAAM2C,GAAIrD,EAAI8C,IAAM,GAAKO,EAAEhC,EAAI,EAAGrB,EAAIkB,KAO/CX,EAAEqE,MAAQrE,EAAE+E,IAAM,SAAUnD,GAC1B,IAAInB,EACFL,EAAIsB,KACJjC,EAAMW,EAAEM,YACRF,EAAKJ,EAAEK,EACPqB,GAAMF,EAAI,IAAInC,EAAImC,IAAInB,EACtB2B,EAAI5B,EAAGK,OACPwB,EAAIP,EAAGjB,OACPkB,EAAI3B,EAAEU,EACNkB,EAAIJ,EAAEd,EAMR,GAHAc,EAAER,EAAIhB,EAAEgB,GAAKQ,EAAER,EAAI,GAAK,GAGnBZ,EAAG,KAAOsB,EAAG,GAEhB,OADAF,EAAEnB,EAAI,CAACmB,EAAEd,EAAI,GACNc,EAiBT,IAbAA,EAAEd,EAAIiB,EAAIC,EAGNI,EAAIC,IACN5B,EAAID,EACJA,EAAKsB,EACLA,EAAKrB,EACLuB,EAAII,EACJA,EAAIC,EACJA,EAAIL,GAIDvB,EAAI,IAAIuE,MAAMhD,EAAII,EAAIC,GAAIL,KAAMvB,EAAEuB,GAAK,EAK5C,IAAKD,EAAIM,EAAGN,KAAM,CAIhB,IAHAM,EAAI,EAGCL,EAAII,EAAIL,EAAGC,EAAID,GAGlBM,EAAI5B,EAAEuB,GAAKF,EAAGC,GAAKvB,EAAGwB,EAAID,EAAI,GAAKM,EACnC5B,EAAEuB,KAAOK,EAAI,GAGbA,EAAIA,EAAI,GAAK,EAGf5B,EAAEuB,GAAKK,EAQT,IAJIA,IAAKT,EAAEd,EACNL,EAAE4C,QAGFtB,EAAItB,EAAEI,QAASJ,IAAIsB,IAAKtB,EAAEO,MAG/B,OAFAY,EAAEnB,EAAIA,EAECmB,GAWT5B,EAAE6E,cAAgB,SAAUvC,EAAIhC,GAC9B,IAAIF,EAAIsB,KACNJ,EAAIlB,EAAEK,EAAE,GAEV,GAAI6B,IAAOrC,EAAW,CACpB,GAAIqC,MAASA,GAAMA,EAAK,GAAKA,EAAK5C,EAChC,MAAMkB,MAAMd,GAGd,IADAM,EAAID,EAAM,IAAIC,EAAEM,YAAYN,KAAMkC,EAAIhC,GAC/BF,EAAEK,EAAEI,OAASyB,GAAKlC,EAAEK,EAAE2C,KAAK,GAGpC,OAAOnC,EAAUb,GAAG,IAAQkB,IAc9BtB,EAAEiF,QAAU,SAAU3C,EAAIhC,GACxB,IAAIF,EAAIsB,KACNJ,EAAIlB,EAAEK,EAAE,GAEV,GAAI6B,IAAOrC,EAAW,CACpB,GAAIqC,MAASA,GAAMA,EAAK,GAAKA,EAAK5C,EAChC,MAAMkB,MAAMd,GAKd,IAAKwC,EAAKA,GAHVlC,EAAID,EAAM,IAAIC,EAAEM,YAAYN,GAAIkC,EAAKlC,EAAEU,EAAI,EAAGR,IAG7BQ,EAAI,EAAGV,EAAEK,EAAEI,OAASyB,GAAKlC,EAAEK,EAAE2C,KAAK,GAGrD,OAAOnC,EAAUb,GAAG,IAASkB,IAU/BtB,EAAEkF,OAASlF,EAAEmF,SAAW,WACtB,IAAI/E,EAAIsB,KACNjC,EAAMW,EAAEM,YACV,OAAOO,EAAUb,EAAGA,EAAEU,GAAKrB,EAAI2F,IAAMhF,EAAEU,GAAKrB,EAAI4F,KAAMjF,EAAEK,EAAE,KAO5DT,EAAEsF,SAAW,WACX,IAAIhE,EAAIiE,OAAOtE,EAAUS,MAAM,GAAM,IACrC,IAAgC,IAA5BA,KAAKhB,YAAY8E,SAAoB9D,KAAK4B,GAAGhC,EAAE6D,YACjD,MAAMvE,MAAMhB,EAAO,wBAErB,OAAO0B,GAaTtB,EAAEyF,YAAc,SAAUpF,EAAIC,GAC5B,IAAIF,EAAIsB,KACNjC,EAAMW,EAAEM,YACRY,EAAIlB,EAAEK,EAAE,GAEV,GAAIJ,IAAOJ,EAAW,CACpB,GAAII,MAASA,GAAMA,EAAK,GAAKA,EAAKX,EAChC,MAAMkB,MAAMf,EAAU,aAGxB,IADAO,EAAID,EAAM,IAAIV,EAAIW,GAAIC,EAAIC,GACnBF,EAAEK,EAAEI,OAASR,GAAKD,EAAEK,EAAE2C,KAAK,GAGpC,OAAOnC,EAAUb,EAAGC,GAAMD,EAAEU,GAAKV,EAAEU,GAAKrB,EAAI2F,IAAMhF,EAAEU,GAAKrB,EAAI4F,KAAM/D,IAUrEtB,EAAE0F,QAAU,WACV,IAAItF,EAAIsB,KACNjC,EAAMW,EAAEM,YACV,IAAmB,IAAfjB,EAAI+F,OACN,MAAM5E,MAAMhB,EAAO,sBAErB,OAAOqB,EAAUb,EAAGA,EAAEU,GAAKrB,EAAI2F,IAAMhF,EAAEU,GAAKrB,EAAI4F,IAAI,IAOtD5F,EAx6BA,SAASkG,IAQP,SAASlG,EAAI6B,GACX,IAAIlB,EAAIsB,KAGR,KAAMtB,aAAaX,GAAM,OAAO6B,IAAMrB,EAAY0F,IAAU,IAAIlG,EAAI6B,GAGpE,GAAIA,aAAa7B,EACfW,EAAEgB,EAAIE,EAAEF,EACRhB,EAAEU,EAAIQ,EAAER,EACRV,EAAEK,EAAIa,EAAEb,EAAEe,YACL,CACL,GAAiB,kBAANF,EAAgB,CACzB,IAAmB,IAAf7B,EAAI+F,OACN,MAAMI,UAAU/F,EAAU,UAI5ByB,EAAU,IAANA,GAAW,EAAIA,EAAI,EAAI,KAAOuE,OAAOvE,IAgCjD,SAAelB,EAAGkB,GAChB,IAAIR,EAAGiB,EAAG+D,EAEV,IAAK5F,EAAQ6F,KAAKzE,GAChB,MAAMV,MAAMf,EAAU,UAIxBO,EAAEgB,EAAmB,KAAfE,EAAEC,OAAO,IAAaD,EAAIA,EAAEE,MAAM,IAAK,GAAK,GAG7CV,EAAIQ,EAAEwD,QAAQ,OAAS,IAAGxD,EAAIA,EAAE0E,QAAQ,IAAK,MAG7CjE,EAAIT,EAAE2E,OAAO,OAAS,GAGrBnF,EAAI,IAAGA,EAAIiB,GACfjB,IAAMQ,EAAEE,MAAMO,EAAI,GAClBT,EAAIA,EAAE4E,UAAU,EAAGnE,IACVjB,EAAI,IAGbA,EAAIQ,EAAET,QAMR,IAHAiF,EAAKxE,EAAET,OAGFkB,EAAI,EAAGA,EAAI+D,GAAqB,KAAfxE,EAAEC,OAAOQ,MAAcA,EAE7C,GAAIA,GAAK+D,EAGP1F,EAAEK,EAAI,CAACL,EAAEU,EAAI,OACR,CAGL,KAAOgF,EAAK,GAAuB,KAAlBxE,EAAEC,SAASuE,KAK5B,IAJA1F,EAAEU,EAAIA,EAAIiB,EAAI,EACd3B,EAAEK,EAAI,GAGDK,EAAI,EAAGiB,GAAK+D,GAAK1F,EAAEK,EAAEK,MAAQQ,EAAEC,OAAOQ,MAxEzCoE,CAAM/F,EAAGkB,GAKXlB,EAAEM,YAAcjB,EAclB,OAXAA,EAAI2G,UAAYpG,EAChBP,EAAI8C,GAjGC,GAkGL9C,EAAIkB,GAxFC,EAyFLlB,EAAI2F,IA5EC,EA6EL3F,EAAI4F,GAtEC,GAuEL5F,EAAI+F,OAhEK,MAiET/F,EAAI4G,UAAY,EAChB5G,EAAI6G,YAAc,EAClB7G,EAAI8G,cAAgB,EACpB9G,EAAI+G,QAAU,EAEP/G,EAw3BHkG,GAENlG,EAAG,QAAcA,EAAIA,IAAMA,OAInB,KAANgH,EAAAA,WAAqB,OAAOhH,GAAtB,8BAv/BT,I,+KCJc,SAASiH,EAAWC,EAAQC,EAAMC,GAc/C,OAZEH,GADE,EAAAI,EAAA,KACWC,QAAQC,UAER,SAAoBL,EAAQC,EAAMC,GAC7C,IAAIzE,EAAI,CAAC,MACTA,EAAEgB,KAAK6D,MAAM7E,EAAGwE,GAChB,IACIM,EAAW,IADGC,SAASC,KAAKH,MAAMN,EAAQvE,IAG9C,OADIyE,IAAO,EAAAQ,EAAA,GAAeH,EAAUL,EAAMT,WACnCc,GAIJR,EAAWO,MAAM,KAAMK,WCZjB,SAASC,EAAiBV,GACvC,IAAIW,EAAwB,oBAARC,IAAqB,IAAIA,SAAQC,EA8BrD,OA5BAH,EAAmB,SAA0BV,GAC3C,GAAc,OAAVA,ICRkCc,EDQEd,GCPsB,IAAzDM,SAAShC,SAASyC,KAAKD,GAAI7C,QAAQ,kBDOQ,OAAO+B,ECR5C,IAA2Bc,EDUtC,GAAqB,oBAAVd,EACT,MAAM,IAAIjB,UAAU,sDAGtB,GAAsB,qBAAX4B,EAAwB,CACjC,GAAIA,EAAOK,IAAIhB,GAAQ,OAAOW,EAAOM,IAAIjB,GAEzCW,EAAOO,IAAIlB,EAAOmB,GAGpB,SAASA,IACP,OAAO,EAAUnB,EAAOS,WAAW,EAAAW,EAAA,GAAevG,MAAMhB,aAW1D,OARAsH,EAAQ5B,UAAY8B,OAAOC,OAAOtB,EAAMT,UAAW,CACjD1F,YAAa,CACX0H,MAAOJ,EACPK,YAAY,EACZC,UAAU,EACVC,cAAc,MAGX,EAAAlB,EAAA,GAAeW,EAASnB,IAG1BU,EAAiBV,GE/BnB,SAAS2B,EAAaJ,GAC3B,MAAuB,iBAATA,GAA+B,OAAVA,ECL9B,SAASK,EAAUC,EAAWC,GAGnC,IAFyBC,QAAQF,GAG/B,MAAM,IAAI9H,MACG,MAAX+H,EAAkBA,EAAU,mCCJlC,IAAME,EAAa,eASZ,SAASC,EAAYC,EAAQC,GAClC,IAD4C,EACxCC,EAAgB,EAChBC,EAAO,EAFiC,UAIxBH,EAAOI,KAAKC,SAASP,IAJG,IAI5C,2BAAsD,KAA3CQ,EAA2C,QAGpD,GAFuB,kBAAhBA,EAAMC,OAAsBb,GAAU,GAEzCY,EAAMC,OAASN,EACjB,MAGFC,EAAgBI,EAAMC,MAAQD,EAAM,GAAGxI,OACvCqI,GAAQ,GAZkC,8BAe5C,MAAO,CACLA,KAAAA,EACAK,OAAQP,EAAW,EAAIC,G,wBCtBpB,SAASO,EAAcC,GAC5B,OAAOC,EACLD,EAASV,OACTD,EAAYW,EAASV,OAAQU,EAASE,QAOnC,SAASD,EAAoBX,EAAQa,GAC1C,IAAMC,EAAwBd,EAAOe,eAAeP,OAAS,EACvDJ,EAAO,GAAGY,SAASF,GAAyBd,EAAOI,KACnDa,EAAYJ,EAAeV,KAAO,EAClCe,EAAalB,EAAOe,eAAeZ,KAAO,EAC1CgB,EAAUN,EAAeV,KAAOe,EAChCE,EAAuC,IAAxBP,EAAeV,KAAaW,EAAwB,EACnEO,EAAYR,EAAeL,OAASY,EACpCE,EAAc,GAAH,OAAMtB,EAAOuB,KAAb,YAAqBJ,EAArB,YAAgCE,EAAhC,MACXG,EAAQpB,EAAKqB,MAAM,gBACnBC,EAAeF,EAAMP,GAE3B,GAAIS,EAAa5J,OAAS,IAAK,CAK7B,IAJA,IAAM6J,EAAe9F,KAAK+F,MAAMP,EAAY,IACtCQ,EAAmBR,EAAY,GAC/BS,EAAW,GAER9I,EAAI,EAAGA,EAAI0I,EAAa5J,OAAQkB,GAAK,GAC5C8I,EAASzH,KAAKqH,EAAajJ,MAAMO,EAAGA,EAAI,KAG1C,OACEsI,EACAS,EAAmB,CACjB,CAAC,GAAD,OAAIZ,EAAJ,MAAiBW,EAAS,KADV,eAEbA,EAASrJ,MAAM,EAAGkJ,EAAe,GAAGK,KAAI,SAACC,GAAD,MAAa,CAAC,IAAKA,OAF9C,CAGhB,CAAC,IAAK,IAAIjB,SAASa,IACnB,CAAC,IAAKC,EAASH,EAAe,OAKpC,OACEL,EACAS,EAAmB,CAEjB,WAAIZ,EAAU,EAAd,MAAqBK,EAAMP,EAAY,IACvC,CAAC,GAAD,OAAIE,EAAJ,MAAiBO,GACjB,CAAC,IAAK,IAAIV,SAASK,IACnB,CAAC,GAAD,OAAIF,EAAU,EAAd,MAAqBK,EAAMP,EAAY,MAK7C,SAASc,EAAmBP,GAC1B,IAAMU,EAAgBV,EAAMW,QAAO,gDAAwBxD,IAAxB,QAC7ByD,EAASvG,KAAKwG,IAAL,MAAAxG,MAAI,OAAQqG,EAAcF,KAAI,kCAAqBlK,YAClE,OAAOoK,EACJF,KAAI,+BAAEM,EAAF,KAAUnC,EAAV,YAAoBmC,EAAOtB,SAASoB,IAAWjC,EAAO,IAAMA,EAAO,OACvE7H,KAAK,MCzDV,SAASiK,EAAiB1E,GACxB,IAAM2E,EAAW3E,EAAK,GAEtB,OAAgB,MAAZ2E,GAAoB,SAAUA,GAAY,WAAYA,EACjD,CACLC,MAAOD,EACPxC,OAAQnC,EAAK,GACb6E,UAAW7E,EAAK,GAChB8E,KAAM9E,EAAK,GACX+E,cAAe/E,EAAK,GACpBgF,WAAYhF,EAAK,IAId2E,EASF,IAAMM,EAAb,4CA8CE,WAAYlD,GAAqB,MAC3BmD,EAAaC,EAAiBC,GADH,0CAATC,EAAS,iCAATA,EAAS,kBAG/B,MACEX,EAAiBW,GADXT,EAAR,EAAQA,MAAOzC,EAAf,EAAeA,OAAQ0C,EAAvB,EAAuBA,UAAWC,EAAlC,EAAkCA,KAAMC,EAAxC,EAAwCA,cAAeC,EAAvD,EAAuDA,YAEvD,cAAMjD,IACD2B,KAAO,eACZ,EAAKoB,KAAgB,OAATA,QAA0B,IAATA,EAAkBA,OAAOhE,EACtD,EAAKiE,cACe,OAAlBA,QAA4C,IAAlBA,EACtBA,OACAjE,EAEN,EAAK8D,MAAQU,EACXlH,MAAMmH,QAAQX,GAASA,EAAQA,EAAQ,CAACA,QAAS9D,GAEnD,IAAM0E,EAAgBF,EACW,QAA9BJ,EAAc,EAAKN,aAAmC,IAAhBM,OACnC,EACAA,EAAYf,KAAI,SAACsB,GAAD,OAAUA,EAAKC,OAAKpB,QAAO,SAACoB,GAAD,OAAgB,MAAPA,MAG1D,EAAKvD,OACQ,OAAXA,QAA8B,IAAXA,EACfA,EACkB,OAAlBqD,QAA4C,IAAlBA,GAEe,QAAxCL,EAAkBK,EAAc,UACb,IAApBL,OAFA,EAIAA,EAAgBhD,OACtB,EAAK0C,UACW,OAAdA,QAAoC,IAAdA,EAClBA,EACkB,OAAlBW,QAA4C,IAAlBA,OAC1B,EACAA,EAAcrB,KAAI,SAACuB,GAAD,OAASA,EAAI3C,SACrC,EAAK4C,UACHd,GAAa1C,EACT0C,EAAUV,KAAI,SAACyB,GAAD,OAAS1D,EAAYC,EAAQyD,MACzB,OAAlBJ,QAA4C,IAAlBA,OAC1B,EACAA,EAAcrB,KAAI,SAACuB,GAAD,OAASxD,EAAYwD,EAAIvD,OAAQuD,EAAI3C,UAC7D,IAAM8C,EAAqBjE,EACP,OAAlBmD,QAA4C,IAAlBA,OACtB,EACAA,EAAcC,YAEE,OAAlBD,QAA4C,IAAlBA,OACxB,EACAA,EAAcC,gBAChBlE,EAnD2B,OAoD/B,EAAKkE,WAI2B,QAH7BI,EACgB,OAAfJ,QAAsC,IAAfA,EACnBA,EACAa,SAAyC,IAATT,EAClCA,EACA9D,OAAOC,OAAO,MAGpBD,OAAOwE,kBAAP,UAA8B,CAC5B/D,QAAS,CACPL,UAAU,EACVD,YAAY,GAEdiC,KAAM,CACJjC,YAAY,GAEdmD,MAAO,CACLnD,YAAY,GAEdU,OAAQ,CACNV,YAAY,GAEdoD,UAAW,CACTpD,YAAY,GAEdsD,cAAe,CACbtD,YAAY,KAQI,OAAlBsD,QACkB,IAAlBA,GACAA,EAAcgB,MAEdzE,OAAO0E,gBAAP,UAA4B,QAAS,CACnCxE,MAAOuD,EAAcgB,MACrBrE,UAAU,EACVC,cAAc,IAEP3H,MAAMiM,kBACfjM,MAAMiM,mBAAN,UAA8BhB,GAE9B3D,OAAO0E,gBAAP,UAA4B,QAAS,CACnCxE,MAAOxH,QAAQ+L,MACfrE,UAAU,EACVC,cAAc,IAtGa,EA9CnC,4BA0JE,WACE,MAAO,iBA3JX,sBA8JE,WACE,IAAIuE,EAASpL,KAAKiH,QAElB,GAAIjH,KAAK8J,MAAO,iBACK9J,KAAK8J,OADV,IACd,2BAA+B,KAApBa,EAAoB,QACzBA,EAAKC,MACPQ,GAAU,OAAStD,EAAc6C,EAAKC,OAH5B,oCAMT,GAAI5K,KAAKqH,QAAUrH,KAAK6K,UAAW,iBACjB7K,KAAK6K,WADY,IACxC,2BAAuC,KAA5B9C,EAA4B,QACrCqD,GAAU,OAASpD,EAAoBhI,KAAKqH,OAAQU,IAFd,+BAM1C,OAAOqD,IA7KX,oBAgLE,WACE,IAAMC,EAAiB,CACrBpE,QAASjH,KAAKiH,SAehB,OAZsB,MAAlBjH,KAAK6K,YACPQ,EAAeR,UAAY7K,KAAK6K,WAGjB,MAAb7K,KAAKgK,OACPqB,EAAerB,KAAOhK,KAAKgK,MAGN,MAAnBhK,KAAKkK,YAAsB1D,OAAO8E,KAAKtL,KAAKkK,YAAY/K,OAAS,IACnEkM,EAAenB,WAAalK,KAAKkK,YAG5BmB,MAjMX,KAAkCnM,OA0J3BqM,OAAOC,aA2Cd,SAAShB,EAAiBiB,GACxB,YAAiBzF,IAAVyF,GAAwC,IAAjBA,EAAMtM,YAAe6G,EAAYyF,EC9N1D,SAASC,EAAYrE,EAAQC,EAAUqE,GAC5C,OAAO,IAAIxB,EAAJ,wBAAkCwB,QAAe3F,EAAWqB,EAAQ,CACzEC,I,ICLOsE,E,UAOX,SAAWA,GACTA,EAAiB,MAAY,QAC7BA,EAAiB,SAAe,WAChCA,EAAiB,aAAmB,eACpCA,EAAiB,MAAY,QAC7BA,EAAiB,oBAA0B,sBAC3CA,EAAiB,gBAAsB,kBACvCA,EAAiB,gBAAsB,kBACvCA,EAAiB,oBAA0B,sBAC3CA,EAAiB,OAAa,SAC9BA,EAAiB,OAAa,SAC9BA,EAAiB,OAAa,SAC9BA,EAAiB,iBAAuB,mBACxCA,EAAiB,oBAA0B,sBAC3CA,EAAiB,UAAgB,YACjCA,EAAiB,MAAY,QAC7BA,EAAiB,KAAW,OAC5BA,EAAiB,WAAiB,aAClCA,EAAiB,aAAmB,eACpCA,EAAiB,uBAA6B,yBAnBhD,CAoBGA,IAAsBA,EAAoB,K,IC1BlCC,E,8BAOX,SAAWA,GACTA,EAAS,IAAU,QACnBA,EAAS,IAAU,QACnBA,EAAS,KAAW,IACpBA,EAAS,OAAa,IACtBA,EAAS,IAAU,IACnBA,EAAS,QAAc,IACvBA,EAAS,QAAc,IACvBA,EAAS,OAAa,MACtBA,EAAS,MAAY,IACrBA,EAAS,OAAa,IACtBA,EAAS,GAAS,IAClBA,EAAS,UAAgB,IACzBA,EAAS,UAAgB,IACzBA,EAAS,QAAc,IACvBA,EAAS,KAAW,IACpBA,EAAS,QAAc,IACvBA,EAAS,KAAW,OACpBA,EAAS,IAAU,MACnBA,EAAS,MAAY,QACrBA,EAAS,OAAa,SACtBA,EAAS,aAAmB,cAC5BA,EAAS,QAAc,UAtBzB,CAuBGA,IAAcA,EAAY,KCpBtB,IAAMC,EAAb,YAgBE,WAAYzE,IAAQ,eAClB,IAAM0E,EAAmB,IAAIC,EAAAA,GAAMH,EAAAA,IAAe,EAAG,EAAG,EAAG,GAC3D7L,KAAKqH,OAASA,EACdrH,KAAKiM,UAAYF,EACjB/L,KAAKkM,MAAQH,EACb/L,KAAKwH,KAAO,EACZxH,KAAKmM,UAAY,EAtBrB,4BAyBE,WACE,MAAO,UA1BX,qBAgCE,WAGE,OAFAnM,KAAKiM,UAAYjM,KAAKkM,MACPlM,KAAKkM,MAAQlM,KAAKoM,cAlCrC,uBA0CE,WACE,IAAIF,EAAQlM,KAAKkM,MAEjB,GAAIA,EAAMG,OAASR,EAAAA,IACjB,GACE,GAAIK,EAAMI,KACRJ,EAAQA,EAAMI,SACT,CAEL,IAAMC,EAAYC,EAAcxM,KAAMkM,EAAMO,KAE5CP,EAAMI,KAAOC,EAEbA,EAAUG,KAAOR,EACjBA,EAAQK,SAEHL,EAAMG,OAASR,EAAAA,SAG1B,OAAOK,MA7DX,GAyBOX,OAAOC,aAsEd,SAASmB,EAAqBC,GAC5B,OACGA,GAAQ,GAAUA,GAAQ,OAAYA,GAAQ,OAAUA,GAAQ,QAYrE,SAASC,EAAyBpF,EAAMM,GACtC,OACE+E,EAAmBrF,EAAKsF,WAAWhF,KACnCiF,EAAoBvF,EAAKsF,WAAWhF,EAAW,IAInD,SAAS+E,EAAmBF,GAC1B,OAAOA,GAAQ,OAAUA,GAAQ,MAGnC,SAASI,EAAoBJ,GAC3B,OAAOA,GAAQ,OAAUA,GAAQ,MAUnC,SAASK,EAAiBC,EAAOnF,GAC/B,IAAM6E,EAAOM,EAAM7F,OAAOI,KAAK0F,YAAYpF,GAE3C,QAAa/B,IAAT4G,EACF,OAAOf,EAAAA,IACF,GAAIe,GAAQ,IAAUA,GAAQ,IAAQ,CAE3C,IAAMQ,EAAOjJ,OAAOkJ,cAAcT,GAClC,MAAgB,MAATQ,EAAe,OAAf,WAA4BA,EAA5B,KAGT,MAAO,KAAOR,EAAKnJ,SAAS,IAAI6J,cAAcjF,SAAS,EAAG,KAM5D,SAASkF,EAAYL,EAAOb,EAAMpE,EAAOwE,EAAK/F,GAC5C,IAAMc,EAAO0F,EAAM1F,KACbgG,EAAM,EAAIvF,EAAQiF,EAAMf,UAC9B,OAAO,IAAIH,EAAAA,GAAMK,EAAMpE,EAAOwE,EAAKjF,EAAMgG,EAAK9G,GAUhD,SAAS8F,EAAcU,EAAOjF,GAK5B,IAJA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACpBgG,EAAahG,EAAKtI,OACpBmI,EAAWW,EAERX,EAAWmG,GAAY,CAC5B,IAAMb,EAAOnF,EAAKsF,WAAWzF,GAE7B,OAAQsF,GAeN,KAAK,MAEL,KAAK,EAEL,KAAK,GAEL,KAAK,KAEDtF,EACF,SAMF,KAAK,KAEDA,IACA4F,EAAM1F,KACR0F,EAAMf,UAAY7E,EAClB,SAEF,KAAK,GAEmC,KAAlCG,EAAKsF,WAAWzF,EAAW,GAC7BA,GAAY,IAEVA,IAGF4F,EAAM1F,KACR0F,EAAMf,UAAY7E,EAClB,SAGF,KAAK,GAEH,OAAOoG,EAAYR,EAAO5F,GAU5B,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,KAAgBvE,EAAUA,EAAW,GAEjE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,OAAkBvE,EAAUA,EAAW,GAEnE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,IAAevE,EAAUA,EAAW,GAEhE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,QAAmBvE,EAAUA,EAAW,GAEpE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,QAAmBvE,EAAUA,EAAW,GAEpE,KAAK,GAEH,GACoC,KAAlCG,EAAKsF,WAAWzF,EAAW,IACO,KAAlCG,EAAKsF,WAAWzF,EAAW,GAE3B,OAAOiG,EAAYL,EAAOrB,EAAAA,OAAkBvE,EAAUA,EAAW,GAGnE,MAEF,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,MAAiBvE,EAAUA,EAAW,GAElE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,OAAkBvE,EAAUA,EAAW,GAEnE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,GAAcvE,EAAUA,EAAW,GAE/D,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,UAAqBvE,EAAUA,EAAW,GAEtE,KAAK,GAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,UAAqBvE,EAAUA,EAAW,GAEtE,KAAK,IAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,QAAmBvE,EAAUA,EAAW,GAEpE,KAAK,IAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,KAAgBvE,EAAUA,EAAW,GAEjE,KAAK,IAEH,OAAOiG,EAAYL,EAAOrB,EAAAA,QAAmBvE,EAAUA,EAAW,GAGpE,KAAK,GAEH,OACoC,KAAlCG,EAAKsF,WAAWzF,EAAW,IACO,KAAlCG,EAAKsF,WAAWzF,EAAW,GAEpBqG,EAAgBT,EAAO5F,GAGzBsG,EAAWV,EAAO5F,GAG7B,IAAIuG,EAAAA,EAAAA,IAAQjB,IAAkB,KAATA,EACnB,OAAOkB,EAAWZ,EAAO5F,EAAUsF,GAGrC,IAAImB,EAAAA,EAAAA,IAAYnB,GACd,OAAOoB,EAASd,EAAO5F,GAGzB,MAAMoE,EACJwB,EAAM7F,OACNC,EACS,KAATsF,EACI,kFACAD,EAAqBC,IAASC,EAAyBpF,EAAMH,GAA7D,gCACyB2F,EAAiBC,EAAO5F,GADjD,kCAEsB2F,EAAiBC,EAAO5F,GAF9C,MAMR,OAAOiG,EAAYL,EAAOrB,EAAAA,IAAe4B,EAAYA,GAYvD,SAASC,EAAYR,EAAOjF,GAK1B,IAJA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACpBgG,EAAahG,EAAKtI,OACpBmI,EAAWW,EAAQ,EAEhBX,EAAWmG,GAAY,CAC5B,IAAMb,EAAOnF,EAAKsF,WAAWzF,GAE7B,GAAa,KAATsF,GAA4B,KAATA,EACrB,MAGF,GAAID,EAAqBC,KACrBtF,MACG,KAAIuF,EAAyBpF,EAAMH,GAGxC,MAFAA,GAAY,GAMhB,OAAOiG,EACLL,EACArB,EAAAA,QACA5D,EACAX,EACAG,EAAK3H,MAAMmI,EAAQ,EAAGX,IAiC1B,SAASwG,EAAWZ,EAAOjF,EAAOgG,GAChC,IAAMxG,EAAOyF,EAAM7F,OAAOI,KACtBH,EAAWW,EACX2E,EAAOqB,EACPC,GAAU,EAMd,GAJa,KAATtB,IACFA,EAAOnF,EAAKsF,aAAazF,IAGd,KAATsF,GAGF,GAFAA,EAAOnF,EAAKsF,aAAazF,IAErBuG,EAAAA,EAAAA,IAAQjB,GACV,MAAMlB,EACJwB,EAAM7F,OACNC,EAFe,oDAG8B2F,EAC3CC,EACA5F,GALa,WAUnBA,EAAW6G,EAAWjB,EAAO5F,EAAUsF,GACvCA,EAAOnF,EAAKsF,WAAWzF,GAsBzB,GAnBa,KAATsF,IACFsB,GAAU,EACVtB,EAAOnF,EAAKsF,aAAazF,GACzBA,EAAW6G,EAAWjB,EAAO5F,EAAUsF,GACvCA,EAAOnF,EAAKsF,WAAWzF,IAGZ,KAATsF,GAA4B,MAATA,IACrBsB,GAAU,EAGG,MAFbtB,EAAOnF,EAAKsF,aAAazF,KAEO,KAATsF,IACrBA,EAAOnF,EAAKsF,aAAazF,IAG3BA,EAAW6G,EAAWjB,EAAO5F,EAAUsF,GACvCA,EAAOnF,EAAKsF,WAAWzF,IAGZ,KAATsF,IAAmBmB,EAAAA,EAAAA,IAAYnB,GACjC,MAAMlB,EACJwB,EAAM7F,OACNC,EAFe,kDAG4B2F,EACzCC,EACA5F,GALa,MAUnB,OAAOiG,EACLL,EACAgB,EAAUrC,EAAAA,MAAkBA,EAAAA,IAC5B5D,EACAX,EACAG,EAAK3H,MAAMmI,EAAOX,IAOtB,SAAS6G,EAAWjB,EAAOjF,EAAOgG,GAChC,KAAKJ,EAAAA,EAAAA,IAAQI,GACX,MAAMvC,EACJwB,EAAM7F,OACNY,EAFe,kDAG4BgF,EACzCC,EACAjF,GALa,MAanB,IAHA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACtBH,EAAWW,EAAQ,GAEhB4F,EAAAA,EAAAA,IAAQpG,EAAKsF,WAAWzF,OAC3BA,EAGJ,OAAOA,EAuBT,SAASsG,EAAWV,EAAOjF,GAOzB,IANA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACpBgG,EAAahG,EAAKtI,OACpBmI,EAAWW,EAAQ,EACnBmG,EAAa9G,EACbZ,EAAQ,GAELY,EAAWmG,GAAY,CAC5B,IAAMb,EAAOnF,EAAKsF,WAAWzF,GAE7B,GAAa,KAATsF,EAEF,OADAlG,GAASe,EAAK3H,MAAMsO,EAAY9G,GACzBiG,EAAYL,EAAOrB,EAAAA,OAAkB5D,EAAOX,EAAW,EAAGZ,GAGnE,GAAa,KAATkG,EAAJ,CAcA,GAAa,KAATA,GAA4B,KAATA,EACrB,MAGF,GAAID,EAAqBC,KACrBtF,MACG,KAAIuF,EAAyBpF,EAAMH,GAGxC,MAAMoE,EACJwB,EAAM7F,OACNC,EAFe,2CAGqB2F,EAClCC,EACA5F,GALa,MAFjBA,GAAY,OArBd,CACEZ,GAASe,EAAK3H,MAAMsO,EAAY9G,GAChC,IAAM+G,EAC8B,MAAlC5G,EAAKsF,WAAWzF,EAAW,GACW,MAAlCG,EAAKsF,WAAWzF,EAAW,GACzBgH,EAAgCpB,EAAO5F,GACvCiH,EAA6BrB,EAAO5F,GACtCkH,EAAqBtB,EAAO5F,GAClCZ,GAAS2H,EAAO3H,MAEhB0H,EADA9G,GAAY+G,EAAOI,MAyBvB,MAAM/C,EAAYwB,EAAM7F,OAAQC,EAAU,wBAG5C,SAASgH,EAAgCpB,EAAO5F,GAK9C,IAJA,IAAMG,EAAOyF,EAAM7F,OAAOI,KACtBiH,EAAQ,EACRD,EAAO,EAEJA,EAAO,IAAI,CAChB,IAAM7B,EAAOnF,EAAKsF,WAAWzF,EAAWmH,KAExC,GAAa,MAAT7B,EAAiB,CAEnB,GAAI6B,EAAO,IAAM9B,EAAqB+B,GACpC,MAGF,MAAO,CACLhI,MAAOvC,OAAOkJ,cAAcqB,GAC5BD,KAAAA,GAMJ,IAFAC,EAASA,GAAS,EAAKC,EAAa/B,IAExB,EACV,MAIJ,MAAMlB,EACJwB,EAAM7F,OACNC,EAFe,4CAGsBG,EAAK3H,MACxCwH,EACAA,EAAWmH,GALE,OAUnB,SAASF,EAA6BrB,EAAO5F,GAC3C,IAAMG,EAAOyF,EAAM7F,OAAOI,KACpBmF,EAAOgC,EAAiBnH,EAAMH,EAAW,GAE/C,GAAIqF,EAAqBC,GACvB,MAAO,CACLlG,MAAOvC,OAAOkJ,cAAcT,GAC5B6B,KAAM,GAKV,GAAI3B,EAAmBF,IAGe,KAAlCnF,EAAKsF,WAAWzF,EAAW,IACO,MAAlCG,EAAKsF,WAAWzF,EAAW,GAC3B,CACA,IAAMuH,EAAeD,EAAiBnH,EAAMH,EAAW,GAEvD,GAAI0F,EAAoB6B,GAOtB,MAAO,CACLnI,MAAOvC,OAAOkJ,cAAcT,EAAMiC,GAClCJ,KAAM,IAMd,MAAM/C,EACJwB,EAAM7F,OACNC,EAFe,4CAGsBG,EAAK3H,MAAMwH,EAAUA,EAAW,GAHtD,OAcnB,SAASsH,EAAiBnH,EAAMH,GAG9B,OACGqH,EAAalH,EAAKsF,WAAWzF,KAAc,GAC3CqH,EAAalH,EAAKsF,WAAWzF,EAAW,KAAO,EAC/CqH,EAAalH,EAAKsF,WAAWzF,EAAW,KAAO,EAChDqH,EAAalH,EAAKsF,WAAWzF,EAAW,IAkB5C,SAASqH,EAAa/B,GACpB,OAAOA,GAAQ,IAAUA,GAAQ,GAC7BA,EAAO,GACPA,GAAQ,IAAUA,GAAQ,GAC1BA,EAAO,GACPA,GAAQ,IAAUA,GAAQ,IAC1BA,EAAO,IACN,EAeP,SAAS4B,EAAqBtB,EAAO5F,GACnC,IAAMG,EAAOyF,EAAM7F,OAAOI,KAG1B,OAFaA,EAAKsF,WAAWzF,EAAW,IAGtC,KAAK,GAEH,MAAO,CACLZ,MAAO,IACP+H,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/H,MAAO,IACP+H,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/H,MAAO,KACP+H,KAAM,GAIZ,MAAM/C,EACJwB,EAAM7F,OACNC,EAFe,8CAGwBG,EAAK3H,MAC1CwH,EACAA,EAAW,GALE,OAsBnB,SAASqG,EAAgBT,EAAOjF,GAS9B,IARA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACpBgG,EAAahG,EAAKtI,OACpBgN,EAAYe,EAAMf,UAClB7E,EAAWW,EAAQ,EACnBmG,EAAa9G,EACbwH,EAAc,GACZC,EAAa,GAEZzH,EAAWmG,GAAY,CAC5B,IAAMb,EAAOnF,EAAKsF,WAAWzF,GAE7B,GACW,KAATsF,GACkC,KAAlCnF,EAAKsF,WAAWzF,EAAW,IACO,KAAlCG,EAAKsF,WAAWzF,EAAW,GAC3B,CACAwH,GAAerH,EAAK3H,MAAMsO,EAAY9G,GACtCyH,EAAWrN,KAAKoN,GAChB,IAAM5C,EAAQqB,EACZL,EACArB,EAAAA,aACA5D,EACAX,EAAW,GACX0H,EAAAA,EAAAA,IAAuBD,GAAYpP,KAAK,OAI1C,OAFAuN,EAAM1F,MAAQuH,EAAW5P,OAAS,EAClC+N,EAAMf,UAAYA,EACXD,EAGT,GACW,KAATU,GACkC,KAAlCnF,EAAKsF,WAAWzF,EAAW,IACO,KAAlCG,EAAKsF,WAAWzF,EAAW,IACO,KAAlCG,EAAKsF,WAAWzF,EAAW,GAS7B,GAAa,KAATsF,GAA4B,KAATA,EAgBvB,GAAID,EAAqBC,KACrBtF,MACG,KAAIuF,EAAyBpF,EAAMH,GAGxC,MAAMoE,EACJwB,EAAM7F,OACNC,EAFe,2CAGqB2F,EAClCC,EACA5F,GALa,MAFjBA,GAAY,OAlBZwH,GAAerH,EAAK3H,MAAMsO,EAAY9G,GACtCyH,EAAWrN,KAAKoN,GAEH,KAATlC,GAAqD,KAAlCnF,EAAKsF,WAAWzF,EAAW,GAChDA,GAAY,IAEVA,EAGJwH,EAAc,GACdV,EAAa9G,EACb6E,EAAY7E,OAnBZwH,GAAerH,EAAK3H,MAAMsO,EAAY9G,GACtC8G,EAAa9G,EAAW,EAExBA,GAAY,EAoChB,MAAMoE,EAAYwB,EAAM7F,OAAQC,EAAU,wBAW5C,SAAS0G,EAASd,EAAOjF,GAKvB,IAJA,IAAMR,EAAOyF,EAAM7F,OAAOI,KACpBgG,EAAahG,EAAKtI,OACpBmI,EAAWW,EAAQ,EAEhBX,EAAWmG,GAAY,CAC5B,IAAMb,EAAOnF,EAAKsF,WAAWzF,GAE7B,KAAI2H,EAAAA,EAAAA,IAAerC,GAGjB,QAFEtF,EAMN,OAAOiG,EACLL,EACArB,EAAAA,KACA5D,EACAX,EACAG,EAAK3H,MAAMmI,EAAOX,I,cCpzBf,IAAM4H,GAAb,WACE,WAAY7H,EAAQ8H,IAAS,eAC3B,IAAMC,GAAYC,EAAAA,EAAAA,GAAShI,GAAUA,EAAS,IAAIiI,EAAAA,EAAOjI,GACzDrH,KAAKuP,OAAS,IAAIzD,EAAMsD,GACxBpP,KAAKwP,SAAWL,EAJpB,wCAUE,WACE,IAAMjD,EAAQlM,KAAKyP,YAAY5D,EAAAA,MAC/B,OAAO7L,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,KACNhJ,MAAOwF,EAAMxF,UAdnB,2BAsBE,WACE,OAAO1G,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,SACNC,YAAa3P,KAAK4P,KAChB/D,EAAAA,IACA7L,KAAK6P,gBACLhE,EAAAA,SA5BR,6BAwDE,WACE,GAAI7L,KAAK8P,KAAKjE,EAAAA,SACZ,OAAO7L,KAAK+P,2BAGd,IAAMC,EAAiBhQ,KAAKiQ,kBACtBC,EAAeF,EACjBhQ,KAAKuP,OAAOnD,YACZpM,KAAKuP,OAAOrD,MAEhB,GAAIgE,EAAa7D,OAASR,EAAAA,KAAgB,CACxC,OAAQqE,EAAaxJ,OACnB,IAAK,SACH,OAAO1G,KAAKmQ,wBAEd,IAAK,SACH,OAAOnQ,KAAKoQ,4BAEd,IAAK,OACH,OAAOpQ,KAAKqQ,4BAEd,IAAK,YACH,OAAOrQ,KAAKsQ,+BAEd,IAAK,QACH,OAAOtQ,KAAKuQ,2BAEd,IAAK,OACH,OAAOvQ,KAAKwQ,0BAEd,IAAK,QACH,OAAOxQ,KAAKyQ,iCAEd,IAAK,YACH,OAAOzQ,KAAK0Q,2BAGhB,GAAIV,EACF,MAAMtE,EACJ1L,KAAKuP,OAAOlI,OACZrH,KAAKuP,OAAOrD,MAAMjE,MAClB,gFAIJ,OAAQiI,EAAaxJ,OACnB,IAAK,QACL,IAAK,WACL,IAAK,eACH,OAAO1G,KAAK+P,2BAEd,IAAK,WACH,OAAO/P,KAAK2Q,0BAEd,IAAK,SACH,OAAO3Q,KAAK4Q,4BAIlB,MAAM5Q,KAAK6Q,WAAWX,KAnH1B,sCA4HE,WACE,IAAMjI,EAAQjI,KAAKuP,OAAOrD,MAE1B,GAAIlM,KAAK8P,KAAKjE,EAAAA,SACZ,OAAO7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,qBACNoB,UAAWC,EAAAA,GAAAA,MACXnI,UAAM5C,EACNgL,oBAAqB,GACrBC,WAAY,GACZC,aAAclR,KAAKmR,sBAIvB,IACIvI,EADEkI,EAAY9Q,KAAKoR,qBAOvB,OAJIpR,KAAK8P,KAAKjE,EAAAA,QACZjD,EAAO5I,KAAKqR,aAGPrR,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,qBACNoB,UAAAA,EACAlI,KAAAA,EACAoI,oBAAqBhR,KAAKsR,2BAC1BL,WAAYjR,KAAKuR,iBAAgB,GACjCL,aAAclR,KAAKmR,wBAvJzB,gCA8JE,WACE,IAAMK,EAAiBxR,KAAKyP,YAAY5D,EAAAA,MAExC,OAAQ2F,EAAe9K,OACrB,IAAK,QACH,OAAOqK,EAAAA,GAAAA,MAET,IAAK,WACH,OAAOA,EAAAA,GAAAA,SAET,IAAK,eACH,OAAOA,EAAAA,GAAAA,aAGX,MAAM/Q,KAAK6Q,WAAWW,KA5K1B,sCAkLE,WACE,OAAOxR,KAAKyR,aACV5F,EAAAA,QACA7L,KAAK0R,wBACL7F,EAAAA,WAtLN,qCA6LE,WACE,OAAO7L,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,oBACNiC,SAAU3R,KAAK4R,gBACfC,MAAO7R,KAAKyP,YAAY5D,EAAAA,OAAkB7L,KAAK8R,sBAC/CC,aAAc/R,KAAKgS,oBAAoBnG,EAAAA,QACnC7L,KAAKiS,8BACLjM,EACJiL,WAAYjR,KAAKkS,2BArMvB,2BA4ME,WACE,IAAMjK,EAAQjI,KAAKuP,OAAOrD,MAE1B,OADAlM,KAAKyP,YAAY5D,EAAAA,QACV7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,SACN9G,KAAM5I,KAAKqR,gBAjNjB,+BA0NE,WACE,OAAOrR,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,cACNyC,WAAYnS,KAAK4P,KACf/D,EAAAA,QACA7L,KAAKoS,eACLvG,EAAAA,aAhOR,4BA2OE,WACE,OAAO7L,KAAK8P,KAAKjE,EAAAA,QACb7L,KAAKqS,gBACLrS,KAAKsS,eA9Ob,wBAsPE,WACE,IAEIC,EACA3J,EAHEX,EAAQjI,KAAKuP,OAAOrD,MACpBsG,EAAcxS,KAAKqR,YAWzB,OAPIrR,KAAKgS,oBAAoBnG,EAAAA,QAC3B0G,EAAQC,EACR5J,EAAO5I,KAAKqR,aAEZzI,EAAO4J,EAGFxS,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,MACN6C,MAAAA,EACA3J,KAAAA,EACAhD,UAAW5F,KAAKyS,gBAAe,GAC/BxB,WAAYjR,KAAKuR,iBAAgB,GACjCL,aAAclR,KAAK8P,KAAKjE,EAAAA,SACpB7L,KAAKmR,yBACLnL,MA3QV,4BAkRE,SAAe0M,GACb,IAAMC,EAAOD,EAAU1S,KAAK4S,mBAAqB5S,KAAK6S,cACtD,OAAO7S,KAAKyR,aAAa5F,EAAAA,QAAmB8G,EAAM9G,EAAAA,WApRtD,2BA0RE,WAA+B,IAAjB6G,EAAiB,wDACvBzK,EAAQjI,KAAKuP,OAAOrD,MACpBtD,EAAO5I,KAAKqR,YAElB,OADArR,KAAKyP,YAAY5D,EAAAA,OACV7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,SACN9G,KAAAA,EACAlC,MAAO1G,KAAK8S,kBAAkBJ,OAjSpC,gCAqSE,WACE,OAAO1S,KAAK6S,eAAc,KAtS9B,2BAiTE,WACE,IAAM5K,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKyP,YAAY5D,EAAAA,QACjB,IAAMkH,EAAmB/S,KAAKgT,sBAAsB,MAEpD,OAAKD,GAAoB/S,KAAK8P,KAAKjE,EAAAA,MAC1B7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,gBACN9G,KAAM5I,KAAKiT,oBACXhC,WAAYjR,KAAKuR,iBAAgB,KAI9BvR,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,gBACNwD,cAAeH,EAAmB/S,KAAKmT,sBAAmBnN,EAC1DiL,WAAYjR,KAAKuR,iBAAgB,GACjCL,aAAclR,KAAKmR,wBAlUzB,qCA4UE,WACE,IAAIiC,EAEEnL,EAAQjI,KAAKuP,OAAOrD,MAK1B,OAJAlM,KAAKqT,cAAc,aAOoC,KAFf,QAApCD,EAAiBpT,KAAKwP,gBAAyC,IAAnB4D,OAC1C,EACAA,EAAeE,8BAEZtT,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,oBACN9G,KAAM5I,KAAKiT,oBACXjC,oBAAqBhR,KAAKsR,2BAC1B4B,eAAgBlT,KAAKqT,cAAc,MAAOrT,KAAKmT,kBAC/ClC,WAAYjR,KAAKuR,iBAAgB,GACjCL,aAAclR,KAAKmR,sBAIhBnR,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,oBACN9G,KAAM5I,KAAKiT,oBACXC,eAAgBlT,KAAKqT,cAAc,MAAOrT,KAAKmT,kBAC/ClC,WAAYjR,KAAKuR,iBAAgB,GACjCL,aAAclR,KAAKmR,wBAxWzB,+BA+WE,WACE,GAAgC,OAA5BnR,KAAKuP,OAAOrD,MAAMxF,MACpB,MAAM1G,KAAK6Q,aAGb,OAAO7Q,KAAKqR,cApXhB,+BA0YE,SAAkBqB,GAChB,IAAMxG,EAAQlM,KAAKuP,OAAOrD,MAE1B,OAAQA,EAAMG,MACZ,KAAKR,EAAAA,UACH,OAAO7L,KAAKuT,UAAUb,GAExB,KAAK7G,EAAAA,QACH,OAAO7L,KAAKwT,YAAYd,GAE1B,KAAK7G,EAAAA,IAGH,OAFA7L,KAAKuP,OAAOkE,UAELzT,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,IACNhJ,MAAOwF,EAAMxF,QAGjB,KAAKmF,EAAAA,MAGH,OAFA7L,KAAKuP,OAAOkE,UAELzT,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,MACNhJ,MAAOwF,EAAMxF,QAGjB,KAAKmF,EAAAA,OACL,KAAKA,EAAAA,aACH,OAAO7L,KAAK0T,qBAEd,KAAK7H,EAAAA,KAGH,OAFA7L,KAAKuP,OAAOkE,UAEJvH,EAAMxF,OACZ,IAAK,OACH,OAAO1G,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,QACNhJ,OAAO,IAGX,IAAK,QACH,OAAO1G,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,QACNhJ,OAAO,IAGX,IAAK,OACH,OAAO1G,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,OAGV,QACE,OAAO1P,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,KACNhJ,MAAOwF,EAAMxF,QAIrB,KAAKmF,EAAAA,OACH,GAAI6G,EAAS,CAGX,GAFA1S,KAAKyP,YAAY5D,EAAAA,QAEb7L,KAAKuP,OAAOrD,MAAMG,OAASR,EAAAA,KAAgB,CAC7C,IAAM8H,EAAU3T,KAAKuP,OAAOrD,MAAMxF,MAClC,MAAMgF,EACJ1L,KAAKuP,OAAOlI,OACZ6E,EAAMjE,MAFS,gCAGU0L,EAHV,yBAMjB,MAAM3T,KAAK6Q,WAAW3E,GAI1B,OAAOlM,KAAK4R,gBAEd,QACE,MAAM5R,KAAK6Q,gBAvdnB,oCA2dE,WACE,OAAO7Q,KAAK8S,mBAAkB,KA5dlC,gCA+dE,WACE,IAAM5G,EAAQlM,KAAKuP,OAAOrD,MAI1B,OAFAlM,KAAKuP,OAAOkE,UAELzT,KAAK2K,KAAKuB,EAAO,CACtBG,KAAMqD,EAAAA,EAAAA,OACNhJ,MAAOwF,EAAMxF,MACbkN,MAAO1H,EAAMG,OAASR,EAAAA,iBAve5B,uBAgfE,SAAU6G,GAAS,WAGjB,OAAO1S,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,KACNmE,OAAQ7T,KAAK8T,IAAIjI,EAAAA,WAJN,kBAAM,EAAKiH,kBAAkBJ,KAII7G,EAAAA,eArflD,yBAggBE,SAAY6G,GAAS,WAGnB,OAAO1S,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,OACNqE,OAAQ/T,KAAK8T,IAAIjI,EAAAA,SAJN,kBAAM,EAAKmI,iBAAiBtB,KAIG7G,EAAAA,aArgBhD,8BA4gBE,SAAiB6G,GACf,IAAMzK,EAAQjI,KAAKuP,OAAOrD,MACpBtD,EAAO5I,KAAKqR,YAElB,OADArR,KAAKyP,YAAY5D,EAAAA,OACV7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,aACN9G,KAAAA,EACAlC,MAAO1G,KAAK8S,kBAAkBJ,OAnhBpC,6BA2hBE,SAAgBA,GAGd,IAFA,IAAMzB,EAAa,GAEZjR,KAAK8P,KAAKjE,EAAAA,KACfoF,EAAWvP,KAAK1B,KAAKiU,eAAevB,IAGtC,OAAOzB,IAliBX,kCAqiBE,WACE,OAAOjR,KAAKuR,iBAAgB,KAtiBhC,4BA8iBE,SAAemB,GACb,IAAMzK,EAAQjI,KAAKuP,OAAOrD,MAE1B,OADAlM,KAAKyP,YAAY5D,EAAAA,IACV7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,UACN9G,KAAM5I,KAAKqR,YACXzL,UAAW5F,KAAKyS,eAAeC,OApjBrC,gCA+jBE,WACE,IACIb,EADE5J,EAAQjI,KAAKuP,OAAOrD,MAG1B,GAAIlM,KAAKgS,oBAAoBnG,EAAAA,WAAsB,CACjD,IAAMqI,EAAYlU,KAAK8R,qBACvB9R,KAAKyP,YAAY5D,EAAAA,WACjBgG,EAAO7R,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,UACNmC,KAAMqC,SAGRrC,EAAO7R,KAAKmT,iBAGd,OAAInT,KAAKgS,oBAAoBnG,EAAAA,MACpB7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,cACNmC,KAAAA,IAIGA,IArlBX,4BA2lBE,WACE,OAAO7R,KAAK2K,KAAK3K,KAAKuP,OAAOrD,MAAO,CAClCG,KAAMqD,EAAAA,EAAAA,WACN9G,KAAM5I,KAAKqR,gBA9lBjB,6BAkmBE,WACE,OAAOrR,KAAK8P,KAAKjE,EAAAA,SAAqB7L,KAAK8P,KAAKjE,EAAAA,gBAnmBpD,8BAymBE,WACE,GAAI7L,KAAKiQ,kBACP,OAAOjQ,KAAK0T,uBA3mBlB,mCAonBE,WACE,IAAMzL,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,UACnB,IAAMpC,EAAajR,KAAKkS,uBAClBkC,EAAiBpU,KAAK4P,KAC1B/D,EAAAA,QACA7L,KAAKqU,6BACLxI,EAAAA,SAEF,OAAO7L,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,kBACN/D,YAAAA,EACAsF,WAAAA,EACAmD,eAAAA,MAloBN,0CAyoBE,WACE,IAAMnM,EAAQjI,KAAKuP,OAAOrD,MACpB4E,EAAY9Q,KAAKoR,qBACvBpR,KAAKyP,YAAY5D,EAAAA,OACjB,IAAMgG,EAAO7R,KAAKmT,iBAClB,OAAOnT,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,0BACNoB,UAAAA,EACAe,KAAAA,MAjpBN,uCAwpBE,WACE,IAAM5J,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,UACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBACxB,OAAOlS,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,uBACN/D,YAAAA,EACA/C,KAAAA,EACAqI,WAAAA,MAlqBN,uCA2qBE,WACE,IAAMhJ,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,QACnB,IAAMzK,EAAO5I,KAAKqR,YACZiD,EAAatU,KAAKuU,4BAClBtD,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKwU,wBACpB,OAAOxU,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,uBACN/D,YAAAA,EACA/C,KAAAA,EACA0L,WAAAA,EACArD,WAAAA,EACA8C,OAAAA,MAzrBN,uCAksBE,WACE,OAAO/T,KAAKgT,sBAAsB,cAC9BhT,KAAKyU,cAAc5I,EAAAA,IAAe7L,KAAKmT,gBACvC,KArsBR,mCA6sBE,WACE,OAAOnT,KAAKyR,aACV5F,EAAAA,QACA7L,KAAK0U,qBACL7I,EAAAA,WAjtBN,kCAytBE,WACE,IAAM5D,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACnBvL,EAAO5I,KAAKqR,YACZnM,EAAOlF,KAAK2U,oBAClB3U,KAAKyP,YAAY5D,EAAAA,OACjB,IAAMgG,EAAO7R,KAAK8R,qBACZb,EAAajR,KAAKkS,uBACxB,OAAOlS,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,iBACN/D,YAAAA,EACA/C,KAAAA,EACAhD,UAAWV,EACX2M,KAAAA,EACAZ,WAAAA,MAvuBN,+BA8uBE,WACE,OAAOjR,KAAKyR,aACV5F,EAAAA,QACA7L,KAAK4U,mBACL/I,EAAAA,WAlvBN,gCA0vBE,WACE,IAAM5D,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACnBvL,EAAO5I,KAAKqR,YAClBrR,KAAKyP,YAAY5D,EAAAA,OACjB,IACIkG,EADEF,EAAO7R,KAAK8R,qBAGd9R,KAAKgS,oBAAoBnG,EAAAA,UAC3BkG,EAAe/R,KAAKiS,0BAGtB,IAAMhB,EAAajR,KAAKkS,uBACxB,OAAOlS,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,uBACN/D,YAAAA,EACA/C,KAAAA,EACAiJ,KAAAA,EACAE,aAAAA,EACAd,WAAAA,MA7wBN,0CAqxBE,WACE,IAAMhJ,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,aACnB,IAAMzK,EAAO5I,KAAKqR,YACZiD,EAAatU,KAAKuU,4BAClBtD,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKwU,wBACpB,OAAOxU,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,0BACN/D,YAAAA,EACA/C,KAAAA,EACA0L,WAAAA,EACArD,WAAAA,EACA8C,OAAAA,MAnyBN,sCA2yBE,WACE,IAAM9L,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,SACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB2C,EAAQ7U,KAAK8U,wBACnB,OAAO9U,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,sBACN/D,YAAAA,EACA/C,KAAAA,EACAqI,WAAAA,EACA4D,MAAAA,MAvzBN,mCAg0BE,WACE,OAAO7U,KAAKgS,oBAAoBnG,EAAAA,QAC5B7L,KAAKyU,cAAc5I,EAAAA,KAAgB7L,KAAKmT,gBACxC,KAn0BR,qCA00BE,WACE,IAAMlL,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,QACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB2B,EAAS7T,KAAK+U,4BACpB,OAAO/U,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,qBACN/D,YAAAA,EACA/C,KAAAA,EACAqI,WAAAA,EACA4C,OAAAA,MAt1BN,uCA+1BE,WACE,OAAO7T,KAAKyR,aACV5F,EAAAA,QACA7L,KAAKgV,yBACLnJ,EAAAA,WAn2BN,sCA02BE,WACE,IAAM5D,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACnBvL,EAAO5I,KAAKiV,qBACZhE,EAAajR,KAAKkS,uBACxB,OAAOlS,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,sBACN/D,YAAAA,EACA/C,KAAAA,EACAqI,WAAAA,MAn3BN,gCA03BE,WACE,GAC8B,SAA5BjR,KAAKuP,OAAOrD,MAAMxF,OACU,UAA5B1G,KAAKuP,OAAOrD,MAAMxF,OACU,SAA5B1G,KAAKuP,OAAOrD,MAAMxF,MAElB,MAAMgF,EACJ1L,KAAKuP,OAAOlI,OACZrH,KAAKuP,OAAOrD,MAAMjE,MAFH,UAGZiN,GACDlV,KAAKuP,OAAOrD,OAJC,uDASnB,OAAOlM,KAAKqR,cAz4BhB,4CAg5BE,WACE,IAAMpJ,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,SACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKmV,6BACpB,OAAOnV,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,6BACN/D,YAAAA,EACA/C,KAAAA,EACAqI,WAAAA,EACA8C,OAAAA,MA55BN,wCAq6BE,WACE,OAAO/T,KAAKyR,aACV5F,EAAAA,QACA7L,KAAK4U,mBACL/I,EAAAA,WAz6BN,sCA07BE,WACE,IAAMqE,EAAelQ,KAAKuP,OAAOnD,YAEjC,GAAI8D,EAAa7D,OAASR,EAAAA,KACxB,OAAQqE,EAAaxJ,OACnB,IAAK,SACH,OAAO1G,KAAKoV,uBAEd,IAAK,SACH,OAAOpV,KAAKqV,2BAEd,IAAK,OACH,OAAOrV,KAAKsV,2BAEd,IAAK,YACH,OAAOtV,KAAKuV,8BAEd,IAAK,QACH,OAAOvV,KAAKwV,0BAEd,IAAK,OACH,OAAOxV,KAAKyV,yBAEd,IAAK,QACH,OAAOzV,KAAK0V,gCAIlB,MAAM1V,KAAK6Q,WAAWX,KAt9B1B,kCAg+BE,WACE,IAAMjI,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,UACnB,IAAMpC,EAAajR,KAAKkS,uBAClBkC,EAAiBpU,KAAKyR,aAC1B5F,EAAAA,QACA7L,KAAKqU,6BACLxI,EAAAA,SAGF,GAA0B,IAAtBoF,EAAW9R,QAA0C,IAA1BiV,EAAejV,OAC5C,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,iBACNuB,WAAAA,EACAmD,eAAAA,MAl/BN,sCA0/BE,WACE,IAAMnM,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,UACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAExB,GAA0B,IAAtBjB,EAAW9R,OACb,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,sBACN9G,KAAAA,EACAqI,WAAAA,MAxgCN,sCAkhCE,WACE,IAAMhJ,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,QACnB,IAAMzK,EAAO5I,KAAKqR,YACZiD,EAAatU,KAAKuU,4BAClBtD,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKwU,wBAEpB,GACwB,IAAtBF,EAAWnV,QACW,IAAtB8R,EAAW9R,QACO,IAAlB4U,EAAO5U,OAEP,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,sBACN9G,KAAAA,EACA0L,WAAAA,EACArD,WAAAA,EACA8C,OAAAA,MAxiCN,yCAkjCE,WACE,IAAM9L,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,aACnB,IAAMzK,EAAO5I,KAAKqR,YACZiD,EAAatU,KAAKuU,4BAClBtD,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKwU,wBAEpB,GACwB,IAAtBF,EAAWnV,QACW,IAAtB8R,EAAW9R,QACO,IAAlB4U,EAAO5U,OAEP,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,yBACN9G,KAAAA,EACA0L,WAAAA,EACArD,WAAAA,EACA8C,OAAAA,MAxkCN,qCAilCE,WACE,IAAM9L,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,SACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB2C,EAAQ7U,KAAK8U,wBAEnB,GAA0B,IAAtB7D,EAAW9R,QAAiC,IAAjB0V,EAAM1V,OACnC,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,qBACN9G,KAAAA,EACAqI,WAAAA,EACA4D,MAAAA,MAjmCN,oCA0mCE,WACE,IAAM5M,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,QACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB2B,EAAS7T,KAAK+U,4BAEpB,GAA0B,IAAtB9D,EAAW9R,QAAkC,IAAlB0U,EAAO1U,OACpC,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,oBACN9G,KAAAA,EACAqI,WAAAA,EACA4C,OAAAA,MA1nCN,2CAmoCE,WACE,IAAM5L,EAAQjI,KAAKuP,OAAOrD,MAC1BlM,KAAKqT,cAAc,UACnBrT,KAAKqT,cAAc,SACnB,IAAMzK,EAAO5I,KAAKqR,YACZJ,EAAajR,KAAKkS,uBAClB6B,EAAS/T,KAAKmV,6BAEpB,GAA0B,IAAtBlE,EAAW9R,QAAkC,IAAlB4U,EAAO5U,OACpC,MAAMa,KAAK6Q,aAGb,OAAO7Q,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,4BACN9G,KAAAA,EACAqI,WAAAA,EACA8C,OAAAA,MAnpCN,sCA6pCE,WACE,IAAM9L,EAAQjI,KAAKuP,OAAOrD,MACpBP,EAAc3L,KAAKmU,mBACzBnU,KAAKqT,cAAc,aACnBrT,KAAKyP,YAAY5D,EAAAA,IACjB,IAAMjD,EAAO5I,KAAKqR,YACZnM,EAAOlF,KAAK2U,oBACZgB,EAAa3V,KAAKgT,sBAAsB,cAC9ChT,KAAKqT,cAAc,MACnB,IAAMxI,EAAY7K,KAAK4V,0BACvB,OAAO5V,KAAK2K,KAAK1C,EAAO,CACtBoE,KAAMqD,EAAAA,EAAAA,qBACN/D,YAAAA,EACA/C,KAAAA,EACAhD,UAAWV,EACXyQ,WAAAA,EACA9K,UAAAA,MA7qCN,qCAsrCE,WACE,OAAO7K,KAAKyU,cAAc5I,EAAAA,KAAgB7L,KAAK6V,0BAvrCnD,oCAqtCE,WACE,IAAM5N,EAAQjI,KAAKuP,OAAOrD,MACpBtD,EAAO5I,KAAKqR,YAElB,GAAI7K,OAAO9B,UAAUoR,eAAe5P,KAAK0F,EAAmBhD,EAAKlC,OAC/D,OAAOkC,EAGT,MAAM5I,KAAK6Q,WAAW5I,KA7tC1B,kBAsuCE,SAAK8N,EAAYpL,GACf,IAAIqL,EAcJ,OATsC,KAFG,QAArCA,EAAkBhW,KAAKwP,gBAA0C,IAApBwG,OAC3C,EACAA,EAAgBC,cAEpBtL,EAAKC,IAAM,IAAIsL,EAAAA,GACbH,EACA/V,KAAKuP,OAAOtD,UACZjM,KAAKuP,OAAOlI,SAITsD,IArvCX,kBA2vCE,SAAK0B,GACH,OAAOrM,KAAKuP,OAAOrD,MAAMG,OAASA,IA5vCtC,yBAmwCE,SAAYA,GACV,IAAMH,EAAQlM,KAAKuP,OAAOrD,MAE1B,GAAIA,EAAMG,OAASA,EAGjB,OAFArM,KAAKuP,OAAOkE,UAELvH,EAGT,MAAMR,EACJ1L,KAAKuP,OAAOlI,OACZ6E,EAAMjE,MAFS,mBAGHkO,GAAiB9J,GAHd,mBAG8B6I,GAAahJ,GAH3C,QA5wCrB,iCAuxCE,SAAoBG,GAGlB,OAFcrM,KAAKuP,OAAOrD,MAEhBG,OAASA,IACjBrM,KAAKuP,OAAOkE,WAEL,KA7xCb,2BAuyCE,SAAc/M,GACZ,IAAMwF,EAAQlM,KAAKuP,OAAOrD,MAE1B,GAAIA,EAAMG,OAASR,EAAAA,MAAkBK,EAAMxF,QAAUA,EAGnD,MAAMgF,EACJ1L,KAAKuP,OAAOlI,OACZ6E,EAAMjE,MAFS,oBAGFvB,EAHE,oBAGewO,GAAahJ,GAH5B,MAFjBlM,KAAKuP,OAAOkE,YA3yClB,mCAyzCE,SAAsB/M,GACpB,IAAMwF,EAAQlM,KAAKuP,OAAOrD,MAE1B,OAAIA,EAAMG,OAASR,EAAAA,MAAkBK,EAAMxF,QAAUA,IACnD1G,KAAKuP,OAAOkE,WAEL,KA/zCb,wBAw0CE,SAAW2C,GACT,IAAMlK,EACQ,OAAZkK,QAAgC,IAAZA,EAAqBA,EAAUpW,KAAKuP,OAAOrD,MACjE,OAAOR,EACL1L,KAAKuP,OAAOlI,OACZ6E,EAAMjE,MAFU,qBAGFiN,GAAahJ,GAHX,QA30CtB,iBAu1CE,SAAImK,EAAUC,EAASC,GACrBvW,KAAKyP,YAAY4G,GAGjB,IAFA,IAAMvM,EAAQ,IAEN9J,KAAKgS,oBAAoBuE,IAC/BzM,EAAMpI,KAAK4U,EAAQpQ,KAAKlG,OAG1B,OAAO8J,IA/1CX,0BAw2CE,SAAauM,EAAUC,EAASC,GAC9B,GAAIvW,KAAKgS,oBAAoBqE,GAAW,CACtC,IAAMvM,EAAQ,GAEd,GACEA,EAAMpI,KAAK4U,EAAQpQ,KAAKlG,cAChBA,KAAKgS,oBAAoBuE,IAEnC,OAAOzM,EAGT,MAAO,KAn3CX,kBA23CE,SAAKuM,EAAUC,EAASC,GACtBvW,KAAKyP,YAAY4G,GACjB,IAAMvM,EAAQ,GAEd,GACEA,EAAMpI,KAAK4U,EAAQpQ,KAAKlG,cAChBA,KAAKgS,oBAAoBuE,IAEnC,OAAOzM,IAn4CX,2BA24CE,SAAc0M,EAAeF,GAC3BtW,KAAKgS,oBAAoBwE,GACzB,IAAM1M,EAAQ,GAEd,GACEA,EAAMpI,KAAK4U,EAAQpQ,KAAKlG,aACjBA,KAAKgS,oBAAoBwE,IAElC,OAAO1M,MAn5CX,KA05CA,SAASoL,GAAahJ,GACpB,IAAMxF,EAAQwF,EAAMxF,MACpB,OAAOyP,GAAiBjK,EAAMG,OAAkB,MAAT3F,EAAA,YAAqBA,EAArB,KAAgC,IAMzE,SAASyP,GAAiB9J,GACxB,ODh6CK,SAA+BA,GACpC,OACEA,IAASR,EAAAA,MACTQ,IAASR,EAAAA,QACTQ,IAASR,EAAAA,KACTQ,IAASR,EAAAA,SACTQ,IAASR,EAAAA,SACTQ,IAASR,EAAAA,QACTQ,IAASR,EAAAA,OACTQ,IAASR,EAAAA,QACTQ,IAASR,EAAAA,IACTQ,IAASR,EAAAA,WACTQ,IAASR,EAAAA,WACTQ,IAASR,EAAAA,SACTQ,IAASR,EAAAA,MACTQ,IAASR,EAAAA,QCi5CJ4K,CAAsBpK,GAAtB,WAAkCA,EAAlC,KAA4CA,ECz+CrD,IAAMqK,GAAW,IAAI3Q,IAGf4Q,GAAoB,IAAI5Q,IAE1B6Q,IAAwB,EACxBC,IAAgC,EAIpC,SAASC,GAAUC,GACjB,OAAOA,EAAOzS,QAAQ,UAAW,KAAK0S,OAUxC,SAASC,GAAiBC,GACxB,IAAMC,EAAW,IAAIC,IACfzH,EAAgC,GAgCtC,OA9BAuH,EAAIvH,YAAY0H,SAAQ,SAAAC,GACtB,GAAgC,uBAA5BA,EAAmBjL,KAA+B,CACpD,IAAIkL,EAAeD,EAAmB1O,KAAKlC,MACvC8Q,EAbDV,IADgBlM,EAca0M,EAAmB1M,KAblCvD,OAAOI,KAAKjD,UAAUoG,EAAI3C,MAAO2C,EAAI6B,MAgBlDgL,EAAed,GAAkBvQ,IAAImR,GACrCE,IAAiBA,EAAatR,IAAIqR,GAGhCZ,IACFc,QAAQC,KAAK,+BAAiCJ,EAAjC,iMAILE,GACVd,GAAkBtQ,IAAIkR,EAAcE,EAAe,IAAIL,KAGzDK,EAAa7U,IAAI4U,GAEZL,EAAShR,IAAIqR,KAChBL,EAASvU,IAAI4U,GACb7H,EAAYjO,KAAK4V,SAGnB3H,EAAYjO,KAAK4V,GArCvB,IAAyB1M,MAyCvB,oBACKsM,GAAG,CACNvH,YAAW,IA0Bf,SAASiI,GAAcvQ,GACrB,IAAIwQ,EAAWf,GAAUzP,GACzB,IAAKqP,GAASvQ,IAAI0R,GAAW,CAC3B,IAAMC,EDhFH,SAAezQ,EAAQ8H,GAE5B,OADe,IAAID,GAAO7H,EAAQ8H,GACpByI,gBC8EGnT,CAAM4C,EAAQ,CAC3BwP,8BAA6B,GAC7BvD,6BAA8BuD,KAEhC,IAAKiB,GAA0B,aAAhBA,EAAOzL,KACpB,MAAM,IAAInN,MAAM,iCAElBwX,GAASrQ,IACPwR,EAjCN,SAAkBE,GAChB,IAAMC,EAAU,IAAIZ,IAAyBW,EAAIpI,aAEjDqI,EAAQX,SAAQ,SAAA1M,GACVA,EAAKC,YAAYD,EAAKC,IAC1BpE,OAAO8E,KAAKX,GAAM0M,SAAQ,SAAAY,GACxB,IAAMvR,EAAQiE,EAAKsN,GACfvR,GAA0B,kBAAVA,GAClBsR,EAAQpV,IAAI8D,SAKlB,IAAMkE,EAAMmN,EAAInN,IAMhB,OALIA,WACKA,EAAImL,kBACJnL,EAAIsN,UAGNH,EAiBHI,CAASlB,GAAiBa,KAG9B,OAAOpB,GAAStQ,IAAIyR,GAIhB,SAAUO,GACdC,G,IACA,oCAAAnT,EAAAA,EAAAA,GAAAA,UAAAA,GAGwB,kBAAbmT,IACTA,EAAW,CAACA,IAGd,IAAIC,EAASD,EAAS,GAWtB,OATAnT,EAAKmS,SAAQ,SAACkB,EAAKlY,GACbkY,GAAoB,aAAbA,EAAIlM,KACbiM,GAAUC,EAAI3N,IAAIvD,OAAOI,KAEzB6Q,GAAUC,EAEZD,GAAUD,EAAShY,EAAI,MAGlBuX,GAAcU,GAoBvB,IAQiBE,GARXC,GACD,GADCA,GAjBA,WACJ/B,GAASgC,QACT/B,GAAkB+B,SAedD,GAZA,WACJ7B,IAAwB,GAWpB6B,GARA,WACJ5B,IAAgC,GAO5B4B,GAJA,WACJ5B,IAAgC,IAWjB2B,GAAAJ,KAAAA,GAAG,KAEhBI,IAKEC,GAJFD,GAAAA,YAIEC,GAHFD,GAAAA,wBAGEC,GAFFD,GAAAA,oCAEEC,GADFD,GAAAA,qCACEC,GAGNL,GAAG,QAAWA,I,iBCpKd,IAAIO,EAAW,SAAU9a,GACvB,aAEA,IAEImI,EAFA4S,EAAKpS,OAAO9B,UACZmU,EAASD,EAAG9C,eAEZgD,EAA4B,oBAAXvN,OAAwBA,OAAS,GAClDwN,EAAiBD,EAAQE,UAAY,aACrCC,EAAsBH,EAAQI,eAAiB,kBAC/CC,EAAoBL,EAAQtN,aAAe,gBAE/C,SAASzG,EAAOqU,EAAKnB,EAAKvR,GAOxB,OANAF,OAAO0E,eAAekO,EAAKnB,EAAK,CAC9BvR,MAAOA,EACPC,YAAY,EACZE,cAAc,EACdD,UAAU,IAELwS,EAAInB,GAEb,IAEElT,EAAO,GAAI,IACX,MAAOsU,GACPtU,EAAS,SAASqU,EAAKnB,EAAKvR,GAC1B,OAAO0S,EAAInB,GAAOvR,GAItB,SAAS4S,EAAKC,EAASC,EAASC,EAAMC,GAEpC,IAAIC,EAAiBH,GAAWA,EAAQ9U,qBAAqBkV,EAAYJ,EAAUI,EAC/EC,EAAYrT,OAAOC,OAAOkT,EAAejV,WACzCoV,EAAU,IAAIC,EAAQL,GAAe,IAMzC,OAFAG,EAAUG,QAuMZ,SAA0BT,EAASE,EAAMK,GACvC,IAAIG,EAAQC,EAEZ,OAAO,SAAgBC,EAAQ5B,GAC7B,GAAI0B,IAAUG,EACZ,MAAM,IAAIlb,MAAM,gCAGlB,GAAI+a,IAAUI,EAAmB,CAC/B,GAAe,UAAXF,EACF,MAAM5B,EAKR,OAAO+B,IAMT,IAHAR,EAAQK,OAASA,EACjBL,EAAQvB,IAAMA,IAED,CACX,IAAIgC,EAAWT,EAAQS,SACvB,GAAIA,EAAU,CACZ,IAAIC,EAAiBC,EAAoBF,EAAUT,GACnD,GAAIU,EAAgB,CAClB,GAAIA,IAAmBE,EAAkB,SACzC,OAAOF,GAIX,GAAuB,SAAnBV,EAAQK,OAGVL,EAAQa,KAAOb,EAAQc,MAAQd,EAAQvB,SAElC,GAAuB,UAAnBuB,EAAQK,OAAoB,CACrC,GAAIF,IAAUC,EAEZ,MADAD,EAAQI,EACFP,EAAQvB,IAGhBuB,EAAQe,kBAAkBf,EAAQvB,SAEN,WAAnBuB,EAAQK,QACjBL,EAAQgB,OAAO,SAAUhB,EAAQvB,KAGnC0B,EAAQG,EAER,IAAIW,EAASC,EAASzB,EAASE,EAAMK,GACrC,GAAoB,WAAhBiB,EAAOlJ,KAAmB,CAO5B,GAJAoI,EAAQH,EAAQmB,KACZZ,EACAa,EAEAH,EAAOxC,MAAQmC,EACjB,SAGF,MAAO,CACLhU,MAAOqU,EAAOxC,IACd0C,KAAMnB,EAAQmB,MAGS,UAAhBF,EAAOlJ,OAChBoI,EAAQI,EAGRP,EAAQK,OAAS,QACjBL,EAAQvB,IAAMwC,EAAOxC,OA/QP4C,CAAiB5B,EAASE,EAAMK,GAE7CD,EAcT,SAASmB,EAAS/U,EAAImT,EAAKb,GACzB,IACE,MAAO,CAAE1G,KAAM,SAAU0G,IAAKtS,EAAGC,KAAKkT,EAAKb,IAC3C,MAAOc,GACP,MAAO,CAAExH,KAAM,QAAS0G,IAAKc,IAhBjCxb,EAAQyb,KAAOA,EAoBf,IAAIY,EAAyB,iBACzBgB,EAAyB,iBACzBd,EAAoB,YACpBC,EAAoB,YAIpBK,EAAmB,GAMvB,SAASd,KACT,SAASwB,KACT,SAASC,KAIT,IAAIC,EAAoB,GACxBvW,EAAOuW,EAAmBvC,GAAgB,WACxC,OAAO/Y,QAGT,IAAIub,EAAW/U,OAAOD,eAClBiV,EAA0BD,GAAYA,EAASA,EAAS1H,EAAO,MAC/D2H,GACAA,IAA4B5C,GAC5BC,EAAO3S,KAAKsV,EAAyBzC,KAGvCuC,EAAoBE,GAGtB,IAAIC,EAAKJ,EAA2B3W,UAClCkV,EAAUlV,UAAY8B,OAAOC,OAAO6U,GAYtC,SAASI,EAAsBhX,GAC7B,CAAC,OAAQ,QAAS,UAAU2S,SAAQ,SAAS8C,GAC3CpV,EAAOL,EAAWyV,GAAQ,SAAS5B,GACjC,OAAOvY,KAAKga,QAAQG,EAAQ5B,SAkClC,SAASoD,EAAc9B,EAAW+B,GAChC,SAASC,EAAO1B,EAAQ5B,EAAKuD,EAASC,GACpC,IAAIhB,EAASC,EAASnB,EAAUM,GAASN,EAAWtB,GACpD,GAAoB,UAAhBwC,EAAOlJ,KAEJ,CACL,IAAIyG,EAASyC,EAAOxC,IAChB7R,EAAQ4R,EAAO5R,MACnB,OAAIA,GACiB,kBAAVA,GACPmS,EAAO3S,KAAKQ,EAAO,WACdkV,EAAYE,QAAQpV,EAAMsV,SAASC,MAAK,SAASvV,GACtDmV,EAAO,OAAQnV,EAAOoV,EAASC,MAC9B,SAAS1C,GACVwC,EAAO,QAASxC,EAAKyC,EAASC,MAI3BH,EAAYE,QAAQpV,GAAOuV,MAAK,SAASC,GAI9C5D,EAAO5R,MAAQwV,EACfJ,EAAQxD,MACP,SAAS6D,GAGV,OAAON,EAAO,QAASM,EAAOL,EAASC,MAvBzCA,EAAOhB,EAAOxC,KA4BlB,IAAI6D,EAgCJpc,KAAKga,QA9BL,SAAiBG,EAAQ5B,GACvB,SAAS8D,IACP,OAAO,IAAIT,GAAY,SAASE,EAASC,GACvCF,EAAO1B,EAAQ5B,EAAKuD,EAASC,MAIjC,OAAOK,EAaLA,EAAkBA,EAAgBH,KAChCI,EAGAA,GACEA,KAkHV,SAAS5B,EAAoBF,EAAUT,GACrC,IAAIK,EAASI,EAASvB,SAASc,EAAQK,QACvC,GAAIA,IAAWnU,EAAW,CAKxB,GAFA8T,EAAQS,SAAW,KAEI,UAAnBT,EAAQK,OAAoB,CAE9B,GAAII,EAASvB,SAAT,SAGFc,EAAQK,OAAS,SACjBL,EAAQvB,IAAMvS,EACdyU,EAAoBF,EAAUT,GAEP,UAAnBA,EAAQK,QAGV,OAAOO,EAIXZ,EAAQK,OAAS,QACjBL,EAAQvB,IAAM,IAAIrU,UAChB,kDAGJ,OAAOwW,EAGT,IAAIK,EAASC,EAASb,EAAQI,EAASvB,SAAUc,EAAQvB,KAEzD,GAAoB,UAAhBwC,EAAOlJ,KAIT,OAHAiI,EAAQK,OAAS,QACjBL,EAAQvB,IAAMwC,EAAOxC,IACrBuB,EAAQS,SAAW,KACZG,EAGT,IAAI4B,EAAOvB,EAAOxC,IAElB,OAAM+D,EAOFA,EAAKrB,MAGPnB,EAAQS,EAASgC,YAAcD,EAAK5V,MAGpCoT,EAAQxN,KAAOiO,EAASiC,QAQD,WAAnB1C,EAAQK,SACVL,EAAQK,OAAS,OACjBL,EAAQvB,IAAMvS,GAUlB8T,EAAQS,SAAW,KACZG,GANE4B,GA3BPxC,EAAQK,OAAS,QACjBL,EAAQvB,IAAM,IAAIrU,UAAU,oCAC5B4V,EAAQS,SAAW,KACZG,GAoDX,SAAS+B,EAAaC,GACpB,IAAIC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,IAGxB1c,KAAKgd,WAAWtb,KAAKib,GAGvB,SAASM,EAAcN,GACrB,IAAI5B,EAAS4B,EAAMO,YAAc,GACjCnC,EAAOlJ,KAAO,gBACPkJ,EAAOxC,IACdoE,EAAMO,WAAanC,EAGrB,SAAShB,EAAQL,GAIf1Z,KAAKgd,WAAa,CAAC,CAAEJ,OAAQ,SAC7BlD,EAAYrC,QAAQoF,EAAczc,MAClCA,KAAKmd,OAAM,GA8Bb,SAAStJ,EAAOuJ,GACd,GAAIA,EAAU,CACZ,IAAIC,EAAiBD,EAASrE,GAC9B,GAAIsE,EACF,OAAOA,EAAenX,KAAKkX,GAG7B,GAA6B,oBAAlBA,EAAS9Q,KAClB,OAAO8Q,EAGT,IAAKE,MAAMF,EAASje,QAAS,CAC3B,IAAIkB,GAAK,EAAGiM,EAAO,SAASA,IAC1B,OAASjM,EAAI+c,EAASje,QACpB,GAAI0Z,EAAO3S,KAAKkX,EAAU/c,GAGxB,OAFAiM,EAAK5F,MAAQ0W,EAAS/c,GACtBiM,EAAK2O,MAAO,EACL3O,EAOX,OAHAA,EAAK5F,MAAQV,EACbsG,EAAK2O,MAAO,EAEL3O,GAGT,OAAOA,EAAKA,KAAOA,GAKvB,MAAO,CAAEA,KAAMgO,GAIjB,SAASA,IACP,MAAO,CAAE5T,MAAOV,EAAWiV,MAAM,GA+MnC,OA7mBAG,EAAkB1W,UAAY2W,EAC9BtW,EAAO0W,EAAI,cAAeJ,GAC1BtW,EAAOsW,EAA4B,cAAeD,GAClDA,EAAkBmC,YAAcxY,EAC9BsW,EACAlC,EACA,qBAaFtb,EAAQ2f,oBAAsB,SAASC,GACrC,IAAIC,EAAyB,oBAAXD,GAAyBA,EAAOze,YAClD,QAAO0e,IACHA,IAAStC,GAG2B,uBAAnCsC,EAAKH,aAAeG,EAAK9U,QAIhC/K,EAAQ8f,KAAO,SAASF,GAQtB,OAPIjX,OAAOb,eACTa,OAAOb,eAAe8X,EAAQpC,IAE9BoC,EAAOG,UAAYvC,EACnBtW,EAAO0Y,EAAQtE,EAAmB,sBAEpCsE,EAAO/Y,UAAY8B,OAAOC,OAAOgV,GAC1BgC,GAOT5f,EAAQggB,MAAQ,SAAStF,GACvB,MAAO,CAAEyD,QAASzD,IAsEpBmD,EAAsBC,EAAcjX,WACpCK,EAAO4W,EAAcjX,UAAWuU,GAAqB,WACnD,OAAOjZ,QAETnC,EAAQ8d,cAAgBA,EAKxB9d,EAAQigB,MAAQ,SAASvE,EAASC,EAASC,EAAMC,EAAakC,QACxC,IAAhBA,IAAwBA,EAAcmC,SAE1C,IAAIC,EAAO,IAAIrC,EACbrC,EAAKC,EAASC,EAASC,EAAMC,GAC7BkC,GAGF,OAAO/d,EAAQ2f,oBAAoBhE,GAC/BwE,EACAA,EAAK1R,OAAO2P,MAAK,SAAS3D,GACxB,OAAOA,EAAO2C,KAAO3C,EAAO5R,MAAQsX,EAAK1R,WAuKjDoP,EAAsBD,GAEtB1W,EAAO0W,EAAItC,EAAmB,aAO9BpU,EAAO0W,EAAI1C,GAAgB,WACzB,OAAO/Y,QAGT+E,EAAO0W,EAAI,YAAY,WACrB,MAAO,wBAkCT5d,EAAQyN,KAAO,SAAS2S,GACtB,IAAI3S,EAAO,GACX,IAAK,IAAI2M,KAAOgG,EACd3S,EAAK5J,KAAKuW,GAMZ,OAJA3M,EAAK9I,UAIE,SAAS8J,IACd,KAAOhB,EAAKnM,QAAQ,CAClB,IAAI8Y,EAAM3M,EAAKhM,MACf,GAAI2Y,KAAOgG,EAGT,OAFA3R,EAAK5F,MAAQuR,EACb3L,EAAK2O,MAAO,EACL3O,EAQX,OADAA,EAAK2O,MAAO,EACL3O,IAsCXzO,EAAQgW,OAASA,EAMjBkG,EAAQrV,UAAY,CAClB1F,YAAa+a,EAEboD,MAAO,SAASe,GAcd,GAbAle,KAAK0M,KAAO,EACZ1M,KAAKsM,KAAO,EAGZtM,KAAK2a,KAAO3a,KAAK4a,MAAQ5U,EACzBhG,KAAKib,MAAO,EACZjb,KAAKua,SAAW,KAEhBva,KAAKma,OAAS,OACdna,KAAKuY,IAAMvS,EAEXhG,KAAKgd,WAAW3F,QAAQ4F,IAEnBiB,EACH,IAAK,IAAItV,KAAQ5I,KAEQ,MAAnB4I,EAAK/I,OAAO,IACZgZ,EAAO3S,KAAKlG,KAAM4I,KACjB0U,OAAO1U,EAAK9I,MAAM,MACrBE,KAAK4I,GAAQ5C,IAMrBmY,KAAM,WACJne,KAAKib,MAAO,EAEZ,IACImD,EADYpe,KAAKgd,WAAW,GACLE,WAC3B,GAAwB,UAApBkB,EAAWvM,KACb,MAAMuM,EAAW7F,IAGnB,OAAOvY,KAAKqe,MAGdxD,kBAAmB,SAASyD,GAC1B,GAAIte,KAAKib,KACP,MAAMqD,EAGR,IAAIxE,EAAU9Z,KACd,SAASue,EAAO3T,EAAK4T,GAYnB,OAXAzD,EAAOlJ,KAAO,QACdkJ,EAAOxC,IAAM+F,EACbxE,EAAQxN,KAAO1B,EAEX4T,IAGF1E,EAAQK,OAAS,OACjBL,EAAQvB,IAAMvS,KAGNwY,EAGZ,IAAK,IAAIne,EAAIL,KAAKgd,WAAW7d,OAAS,EAAGkB,GAAK,IAAKA,EAAG,CACpD,IAAIsc,EAAQ3c,KAAKgd,WAAW3c,GACxB0a,EAAS4B,EAAMO,WAEnB,GAAqB,SAAjBP,EAAMC,OAIR,OAAO2B,EAAO,OAGhB,GAAI5B,EAAMC,QAAU5c,KAAK0M,KAAM,CAC7B,IAAI+R,EAAW5F,EAAO3S,KAAKyW,EAAO,YAC9B+B,EAAa7F,EAAO3S,KAAKyW,EAAO,cAEpC,GAAI8B,GAAYC,EAAY,CAC1B,GAAI1e,KAAK0M,KAAOiQ,EAAME,SACpB,OAAO0B,EAAO5B,EAAME,UAAU,GACzB,GAAI7c,KAAK0M,KAAOiQ,EAAMG,WAC3B,OAAOyB,EAAO5B,EAAMG,iBAGjB,GAAI2B,GACT,GAAIze,KAAK0M,KAAOiQ,EAAME,SACpB,OAAO0B,EAAO5B,EAAME,UAAU,OAG3B,KAAI6B,EAMT,MAAM,IAAIxf,MAAM,0CALhB,GAAIc,KAAK0M,KAAOiQ,EAAMG,WACpB,OAAOyB,EAAO5B,EAAMG,gBAU9BhC,OAAQ,SAASjJ,EAAM0G,GACrB,IAAK,IAAIlY,EAAIL,KAAKgd,WAAW7d,OAAS,EAAGkB,GAAK,IAAKA,EAAG,CACpD,IAAIsc,EAAQ3c,KAAKgd,WAAW3c,GAC5B,GAAIsc,EAAMC,QAAU5c,KAAK0M,MACrBmM,EAAO3S,KAAKyW,EAAO,eACnB3c,KAAK0M,KAAOiQ,EAAMG,WAAY,CAChC,IAAI6B,EAAehC,EACnB,OAIAgC,IACU,UAAT9M,GACS,aAATA,IACD8M,EAAa/B,QAAUrE,GACvBA,GAAOoG,EAAa7B,aAGtB6B,EAAe,MAGjB,IAAI5D,EAAS4D,EAAeA,EAAazB,WAAa,GAItD,OAHAnC,EAAOlJ,KAAOA,EACdkJ,EAAOxC,IAAMA,EAEToG,GACF3e,KAAKma,OAAS,OACdna,KAAKsM,KAAOqS,EAAa7B,WAClBpC,GAGF1a,KAAK4e,SAAS7D,IAGvB6D,SAAU,SAAS7D,EAAQgC,GACzB,GAAoB,UAAhBhC,EAAOlJ,KACT,MAAMkJ,EAAOxC,IAcf,MAXoB,UAAhBwC,EAAOlJ,MACS,aAAhBkJ,EAAOlJ,KACT7R,KAAKsM,KAAOyO,EAAOxC,IACM,WAAhBwC,EAAOlJ,MAChB7R,KAAKqe,KAAOre,KAAKuY,IAAMwC,EAAOxC,IAC9BvY,KAAKma,OAAS,SACdna,KAAKsM,KAAO,OACa,WAAhByO,EAAOlJ,MAAqBkL,IACrC/c,KAAKsM,KAAOyQ,GAGPrC,GAGTmE,OAAQ,SAAS/B,GACf,IAAK,IAAIzc,EAAIL,KAAKgd,WAAW7d,OAAS,EAAGkB,GAAK,IAAKA,EAAG,CACpD,IAAIsc,EAAQ3c,KAAKgd,WAAW3c,GAC5B,GAAIsc,EAAMG,aAAeA,EAGvB,OAFA9c,KAAK4e,SAASjC,EAAMO,WAAYP,EAAMI,UACtCE,EAAcN,GACPjC,IAKb,MAAS,SAASkC,GAChB,IAAK,IAAIvc,EAAIL,KAAKgd,WAAW7d,OAAS,EAAGkB,GAAK,IAAKA,EAAG,CACpD,IAAIsc,EAAQ3c,KAAKgd,WAAW3c,GAC5B,GAAIsc,EAAMC,SAAWA,EAAQ,CAC3B,IAAI7B,EAAS4B,EAAMO,WACnB,GAAoB,UAAhBnC,EAAOlJ,KAAkB,CAC3B,IAAIiN,EAAS/D,EAAOxC,IACpB0E,EAAcN,GAEhB,OAAOmC,GAMX,MAAM,IAAI5f,MAAM,0BAGlB6f,cAAe,SAAS3B,EAAUb,EAAYC,GAa5C,OAZAxc,KAAKua,SAAW,CACdvB,SAAUnF,EAAOuJ,GACjBb,WAAYA,EACZC,QAASA,GAGS,SAAhBxc,KAAKma,SAGPna,KAAKuY,IAAMvS,GAGN0U,IAQJ7c,EA9sBM,CAqtBgBD,EAAOC,SAGtC,IACEmhB,mBAAqBrG,EACrB,MAAOsG,GAWmB,kBAAfC,WACTA,WAAWF,mBAAqBrG,EAEhClT,SAAS,IAAK,yBAAdA,CAAwCkT,K,kCC/uB5C,SAASwG,EAAmBC,EAAKtD,EAASC,EAAQsD,EAAOC,EAAQrH,EAAKM,GACpE,IACE,IAAI+D,EAAO8C,EAAInH,GAAKM,GAChB7R,EAAQ4V,EAAK5V,MACjB,MAAOyV,GAEP,YADAJ,EAAOI,GAILG,EAAKrB,KACPa,EAAQpV,GAERqX,QAAQjC,QAAQpV,GAAOuV,KAAKoD,EAAOC,GAIxB,SAASC,EAAkBtZ,GACxC,OAAO,WACL,IAAIwT,EAAOzZ,KACPkF,EAAOU,UACX,OAAO,IAAImY,SAAQ,SAAUjC,EAASC,GACpC,IAAIqD,EAAMnZ,EAAGV,MAAMkU,EAAMvU,GAEzB,SAASma,EAAM3Y,GACbyY,EAAmBC,EAAKtD,EAASC,EAAQsD,EAAOC,EAAQ,OAAQ5Y,GAGlE,SAAS4Y,EAAOjG,GACd8F,EAAmBC,EAAKtD,EAASC,EAAQsD,EAAOC,EAAQ,QAASjG,GAGnEgG,OAAMrZ,O,kEC/BG,SAASwZ,EAAuBC,EAASC,GAKtD,OAJKA,IACHA,EAAMD,EAAQ3f,MAAM,IAGf0G,OAAOmZ,OAAOnZ,OAAOwE,iBAAiByU,EAAS,CACpDC,IAAK,CACHhZ,MAAOF,OAAOmZ,OAAOD,O","sources":["../node_modules/@babel/runtime/regenerator/index.js","../node_modules/big.js/big.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../node_modules/graphql-tag/src/index.ts","../node_modules/regenerator-runtime/runtime.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js"],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","/*\r\n *  big.js v6.1.1\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2021 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */\r\n;(function (GLOBAL) {\r\n  'use strict';\r\n  var Big,\r\n\r\n\r\n/************************************** EDITABLE DEFAULTS *****************************************/\r\n\r\n\r\n    // The default values below must be integers within the stated ranges.\r\n\r\n    /*\r\n     * The maximum number of decimal places (DP) of the results of operations involving division:\r\n     * div and sqrt, and pow with negative exponents.\r\n     */\r\n    DP = 20,            // 0 to MAX_DP\r\n\r\n    /*\r\n     * The rounding mode (RM) used when rounding to the above decimal places.\r\n     *\r\n     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n     *  3  Away from zero.                                  (ROUND_UP)\r\n     */\r\n    RM = 1,             // 0, 1, 2 or 3\r\n\r\n    // The maximum value of DP and Big.DP.\r\n    MAX_DP = 1E6,       // 0 to 1000000\r\n\r\n    // The maximum magnitude of the exponent argument to the pow method.\r\n    MAX_POWER = 1E6,    // 1 to 1000000\r\n\r\n    /*\r\n     * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n     * (JavaScript numbers: -7)\r\n     * -1000000 is the minimum recommended exponent value of a Big.\r\n     */\r\n    NE = -7,            // 0 to -1000000\r\n\r\n    /*\r\n     * The positive exponent (PE) at and above which toString returns exponential notation.\r\n     * (JavaScript numbers: 21)\r\n     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n     */\r\n    PE = 21,            // 0 to 1000000\r\n\r\n    /*\r\n     * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n     * primitive number without a loss of precision.\r\n     */\r\n    STRICT = false,     // true or false\r\n\r\n\r\n/**************************************************************************************************/\r\n\r\n\r\n    // Error messages.\r\n    NAME = '[big.js] ',\r\n    INVALID = NAME + 'Invalid ',\r\n    INVALID_DP = INVALID + 'decimal places',\r\n    INVALID_RM = INVALID + 'rounding mode',\r\n    DIV_BY_ZERO = NAME + 'Division by zero',\r\n\r\n    // The shared prototype object.\r\n    P = {},\r\n    UNDEFINED = void 0,\r\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\r\n\r\n\r\n  /*\r\n   * Create and return a Big constructor.\r\n   */\r\n  function _Big_() {\r\n\r\n    /*\r\n     * The Big constructor and exported function.\r\n     * Create and return a new instance of a Big number object.\r\n     *\r\n     * n {number|string|Big} A numeric value.\r\n     */\r\n    function Big(n) {\r\n      var x = this;\r\n\r\n      // Enable constructor usage without new.\r\n      if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\r\n\r\n      // Duplicate.\r\n      if (n instanceof Big) {\r\n        x.s = n.s;\r\n        x.e = n.e;\r\n        x.c = n.c.slice();\r\n      } else {\r\n        if (typeof n !== 'string') {\r\n          if (Big.strict === true) {\r\n            throw TypeError(INVALID + 'number');\r\n          }\r\n\r\n          // Minus zero?\r\n          n = n === 0 && 1 / n < 0 ? '-0' : String(n);\r\n        }\r\n\r\n        parse(x, n);\r\n      }\r\n\r\n      // Retain a reference to this Big constructor.\r\n      // Shadow Big.prototype.constructor which points to Object.\r\n      x.constructor = Big;\r\n    }\r\n\r\n    Big.prototype = P;\r\n    Big.DP = DP;\r\n    Big.RM = RM;\r\n    Big.NE = NE;\r\n    Big.PE = PE;\r\n    Big.strict = STRICT;\r\n    Big.roundDown = 0;\r\n    Big.roundHalfUp = 1;\r\n    Big.roundHalfEven = 2;\r\n    Big.roundUp = 3;\r\n\r\n    return Big;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the number or string value passed to a Big constructor.\r\n   *\r\n   * x {Big} A Big number instance.\r\n   * n {number|string} A numeric value.\r\n   */\r\n  function parse(x, n) {\r\n    var e, i, nl;\r\n\r\n    if (!NUMERIC.test(n)) {\r\n      throw Error(INVALID + 'number');\r\n    }\r\n\r\n    // Determine sign.\r\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n    // Decimal point?\r\n    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = n.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +n.slice(i + 1);\r\n      n = n.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = n.length;\r\n    }\r\n\r\n    nl = n.length;\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\r\n\r\n    if (i == nl) {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    } else {\r\n\r\n      // Determine trailing zeros.\r\n      for (; nl > 0 && n.charAt(--nl) == '0';);\r\n      x.e = e - i - 1;\r\n      x.c = [];\r\n\r\n      // Convert string to array of digits without leading/trailing zeros.\r\n      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n   *\r\n   * x {Big} The Big to round.\r\n   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   * [more] {boolean} Whether the result of division was truncated.\r\n   */\r\n  function round(x, sd, rm, more) {\r\n    var xc = x.c;\r\n\r\n    if (rm === UNDEFINED) rm = x.constructor.RM;\r\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\r\n      throw Error(INVALID_RM);\r\n    }\r\n\r\n    if (sd < 1) {\r\n      more =\r\n        rm === 3 && (more || !!xc[0]) || sd === 0 && (\r\n        rm === 1 && xc[0] >= 5 ||\r\n        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\r\n      );\r\n\r\n      xc.length = 1;\r\n\r\n      if (more) {\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        x.e = x.e - sd + 1;\r\n        xc[0] = 1;\r\n      } else {\r\n\r\n        // Zero.\r\n        xc[0] = x.e = 0;\r\n      }\r\n    } else if (sd < xc.length) {\r\n\r\n      // xc[sd] is the digit after the digit that may be rounded up.\r\n      more =\r\n        rm === 1 && xc[sd] >= 5 ||\r\n        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\r\n          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\r\n        rm === 3 && (more || !!xc[0]);\r\n\r\n      // Remove any digits after the required precision.\r\n      xc.length = sd--;\r\n\r\n      // Round up?\r\n      if (more) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up.\r\n        for (; ++xc[sd] > 9;) {\r\n          xc[sd] = 0;\r\n          if (!sd--) {\r\n            ++x.e;\r\n            xc.unshift(1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (sd = xc.length; !xc[--sd];) xc.pop();\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of Big x in normal or exponential notation.\r\n   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n   */\r\n  function stringify(x, doExponential, isNonzero) {\r\n    var e = x.e,\r\n      s = x.c.join(''),\r\n      n = s.length;\r\n\r\n    // Exponential notation?\r\n    if (doExponential) {\r\n      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\r\n\r\n    // Normal notation.\r\n    } else if (e < 0) {\r\n      for (; ++e;) s = '0' + s;\r\n      s = '0.' + s;\r\n    } else if (e > 0) {\r\n      if (++e > n) {\r\n        for (e -= n; e--;) s += '0';\r\n      } else if (e < n) {\r\n        s = s.slice(0, e) + '.' + s.slice(e);\r\n      }\r\n    } else if (n > 1) {\r\n      s = s.charAt(0) + '.' + s.slice(1);\r\n    }\r\n\r\n    return x.s < 0 && isNonzero ? '-' + s : s;\r\n  }\r\n\r\n\r\n  // Prototype/instance methods\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the absolute value of this Big.\r\n   */\r\n  P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return 1 if the value of this Big is greater than the value of Big y,\r\n   *       -1 if the value of this Big is less than the value of Big y, or\r\n   *        0 if they have the same value.\r\n   */\r\n  P.cmp = function (y) {\r\n    var isneg,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new x.constructor(y)).c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    isneg = i < 0;\r\n\r\n    // Compare exponents.\r\n    if (k != l) return k > l ^ isneg ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = -1; ++i < j;) {\r\n      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.div = function (y) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      a = x.c,                  // dividend\r\n      b = (y = new Big(y)).c,   // divisor\r\n      k = x.s == y.s ? 1 : -1,\r\n      dp = Big.DP;\r\n\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n\r\n    // Divisor is zero?\r\n    if (!b[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    // Dividend is 0? Return +-0.\r\n    if (!a[0]) {\r\n      y.s = k;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    var bl, bt, n, cmp, ri,\r\n      bz = b.slice(),\r\n      ai = bl = b.length,\r\n      al = a.length,\r\n      r = a.slice(0, bl),   // remainder\r\n      rl = r.length,\r\n      q = y,                // quotient\r\n      qc = q.c = [],\r\n      qi = 0,\r\n      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\r\n\r\n    q.s = k;\r\n    k = p < 0 ? 0 : p;\r\n\r\n    // Create version of divisor with leading zero.\r\n    bz.unshift(0);\r\n\r\n    // Add zeros to make remainder as long as divisor.\r\n    for (; rl++ < bl;) r.push(0);\r\n\r\n    do {\r\n\r\n      // n is how many times the divisor goes into current remainder.\r\n      for (n = 0; n < 10; n++) {\r\n\r\n        // Compare divisor and remainder.\r\n        if (bl != (rl = r.length)) {\r\n          cmp = bl > rl ? 1 : -1;\r\n        } else {\r\n          for (ri = -1, cmp = 0; ++ri < bl;) {\r\n            if (b[ri] != r[ri]) {\r\n              cmp = b[ri] > r[ri] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // If divisor < remainder, subtract divisor from remainder.\r\n        if (cmp < 0) {\r\n\r\n          // Remainder can't be more than 1 digit longer than divisor.\r\n          // Equalise lengths using divisor with extra leading zero?\r\n          for (bt = rl == bl ? b : bz; rl;) {\r\n            if (r[--rl] < bt[rl]) {\r\n              ri = rl;\r\n              for (; ri && !r[--ri];) r[ri] = 9;\r\n              --r[ri];\r\n              r[rl] += 10;\r\n            }\r\n            r[rl] -= bt[rl];\r\n          }\r\n\r\n          for (; !r[0];) r.shift();\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Add the digit n to the result array.\r\n      qc[qi++] = cmp ? n : ++n;\r\n\r\n      // Update the remainder.\r\n      if (r[0] && cmp) r[rl] = a[ai] || 0;\r\n      else r = [a[ai]];\r\n\r\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\r\n\r\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n    if (!qc[0] && qi != 1) {\r\n\r\n      // There can't be more than one zero.\r\n      qc.shift();\r\n      q.e--;\r\n      p--;\r\n    }\r\n\r\n    // Round?\r\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\r\n\r\n    return q;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n   */\r\n  P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n   * false.\r\n   */\r\n  P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.gte = function (y) {\r\n    return this.cmp(y) > -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n   */\r\n  P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var i, j, t, xlty,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xc = x.c.slice(),\r\n      xe = x.e,\r\n      yc = y.c,\r\n      ye = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (yc[0]) {\r\n        y.s = -b;\r\n      } else if (xc[0]) {\r\n        y = new Big(x);\r\n      } else {\r\n        y.s = 1;\r\n      }\r\n      return y;\r\n    }\r\n\r\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\r\n    if (a = xe - ye) {\r\n\r\n      if (xlty = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (b = a; b--;) t.push(0);\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = ((xlty = xc.length < yc.length) ? xc : yc).length;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n        if (xc[b] != yc[b]) {\r\n          xlty = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xlty) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    /*\r\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n     * needs to start at yc.length.\r\n     */\r\n    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\r\n\r\n    // Subtract yc from xc.\r\n    for (b = i; j > a;) {\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i];) xc[i] = 9;\r\n        --xc[i];\r\n        xc[j] += 10;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xc[--b] === 0;) xc.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] === 0;) {\r\n      xc.shift();\r\n      --ye;\r\n    }\r\n\r\n    if (!xc[0]) {\r\n\r\n      // n - n = +0\r\n      y.s = 1;\r\n\r\n      // Result must be zero.\r\n      xc = [ye = 0];\r\n    }\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n   */\r\n  P.mod = function (y) {\r\n    var ygtx,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    if (!y.c[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    x.s = y.s = 1;\r\n    ygtx = y.cmp(x) == 1;\r\n    x.s = a;\r\n    y.s = b;\r\n\r\n    if (ygtx) return new Big(x);\r\n\r\n    a = Big.DP;\r\n    b = Big.RM;\r\n    Big.DP = Big.RM = 0;\r\n    x = x.div(y);\r\n    Big.DP = a;\r\n    Big.RM = b;\r\n\r\n    return this.minus(x.times(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var e, k, t,\r\n      x = this,\r\n      Big = x.constructor;\r\n\r\n    y = new Big(y);\r\n\r\n    // Signs differ?\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e,\r\n      xc = x.c,\r\n      ye = y.e,\r\n      yc = y.c;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (!yc[0]) {\r\n        if (xc[0]) {\r\n          y = new Big(x);\r\n        } else {\r\n          y.s = x.s;\r\n        }\r\n      }\r\n      return y;\r\n    }\r\n\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    // Note: reverse faster than unshifts.\r\n    if (e = xe - ye) {\r\n      if (e > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        e = -e;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; e--;) t.push(0);\r\n      t.reverse();\r\n    }\r\n\r\n    // Point xc to the longer array.\r\n    if (xc.length - yc.length < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n    }\r\n\r\n    e = yc.length;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\r\n    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n    if (k) {\r\n      xc.unshift(k);\r\n      ++ye;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (e = xc.length; xc[--e] === 0;) xc.pop();\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a Big whose value is the value of this Big raised to the power n.\r\n   * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n   * mode Big.RM.\r\n   *\r\n   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n   */\r\n  P.pow = function (n) {\r\n    var x = this,\r\n      one = new x.constructor('1'),\r\n      y = one,\r\n      isneg = n < 0;\r\n\r\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n      throw Error(INVALID + 'exponent');\r\n    }\r\n\r\n    if (isneg) n = -n;\r\n\r\n    for (;;) {\r\n      if (n & 1) y = y.times(x);\r\n      n >>= 1;\r\n      if (!n) break;\r\n      x = x.times(x);\r\n    }\r\n\r\n    return isneg ? one.div(y) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n   * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.prec = function (sd, rm) {\r\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n      throw Error(INVALID + 'precision');\r\n    }\r\n    return round(new this.constructor(this), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n   * using rounding mode rm, or Big.RM if rm is not specified.\r\n   * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n   * If dp is not specified, round to 0 decimal places.\r\n   *\r\n   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.round = function (dp, rm) {\r\n    if (dp === UNDEFINED) dp = 0;\r\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    return round(new this.constructor(this), dp + this.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.sqrt = function () {\r\n    var r, c, t,\r\n      x = this,\r\n      Big = x.constructor,\r\n      s = x.s,\r\n      e = x.e,\r\n      half = new Big('0.5');\r\n\r\n    // Zero?\r\n    if (!x.c[0]) return new Big(x);\r\n\r\n    // Negative?\r\n    if (s < 0) {\r\n      throw Error(NAME + 'No square root');\r\n    }\r\n\r\n    // Estimate.\r\n    s = Math.sqrt(x + '');\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\r\n    if (s === 0 || s === 1 / 0) {\r\n      c = x.c.join('');\r\n      if (!(c.length + e & 1)) c += '0';\r\n      s = Math.sqrt(c);\r\n      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\r\n    } else {\r\n      r = new Big(s + '');\r\n    }\r\n\r\n    e = r.e + (Big.DP += 4);\r\n\r\n    // Newton-Raphson iteration.\r\n    do {\r\n      t = r;\r\n      r = half.times(t.plus(x.div(t)));\r\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\r\n\r\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big times the value of Big y.\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var c,\r\n      x = this,\r\n      Big = x.constructor,\r\n      xc = x.c,\r\n      yc = (y = new Big(y)).c,\r\n      a = xc.length,\r\n      b = yc.length,\r\n      i = x.e,\r\n      j = y.e;\r\n\r\n    // Determine sign of result.\r\n    y.s = x.s == y.s ? 1 : -1;\r\n\r\n    // Return signed 0 if either 0.\r\n    if (!xc[0] || !yc[0]) {\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // Initialise exponent of result as x.e + y.e.\r\n    y.e = i + j;\r\n\r\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n    if (a < b) {\r\n      c = xc;\r\n      xc = yc;\r\n      yc = c;\r\n      j = a;\r\n      a = b;\r\n      b = j;\r\n    }\r\n\r\n    // Initialise coefficient array of result with zeros.\r\n    for (c = new Array(j = a + b); j--;) c[j] = 0;\r\n\r\n    // Multiply.\r\n\r\n    // i is initially xc.length.\r\n    for (i = b; i--;) {\r\n      b = 0;\r\n\r\n      // a is yc.length.\r\n      for (j = a + i; j > i;) {\r\n\r\n        // Current sum of products at this digit position, plus carry.\r\n        b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n        c[j--] = b % 10;\r\n\r\n        // carry\r\n        b = b / 10 | 0;\r\n      }\r\n\r\n      c[j] = b;\r\n    }\r\n\r\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\r\n    if (b) ++y.e;\r\n    else c.shift();\r\n\r\n    // Remove trailing zeros.\r\n    for (i = c.length; !c[--i];) c.pop();\r\n    y.c = c;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), ++dp, rm);\r\n      for (; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, true, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), dp + x.e + 1, rm);\r\n\r\n      // x.e may have changed if the value is rounded up.\r\n      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, false, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Omit the sign for negative zero.\r\n   */\r\n  P.toJSON = P.toString = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Big as a primitve number.\r\n   */\r\n  P.toNumber = function () {\r\n    var n = Number(stringify(this, true, true));\r\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\r\n      throw Error(NAME + 'Imprecise conversion');\r\n    }\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big rounded to sd significant digits using\r\n   * rounding mode rm, or Big.RM if rm is not specified.\r\n   * Use exponential notation if sd is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      n = x.c[0];\r\n\r\n    if (sd !== UNDEFINED) {\r\n      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n        throw Error(INVALID + 'precision');\r\n      }\r\n      x = round(new Big(x), sd, rm);\r\n      for (; x.c.length < sd;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Include the sign for negative zero.\r\n   */\r\n  P.valueOf = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    if (Big.strict === true) {\r\n      throw Error(NAME + 'valueOf disallowed');\r\n    }\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\r\n  };\r\n\r\n\r\n  // Export\r\n\r\n\r\n  Big = _Big_();\r\n\r\n  Big['default'] = Big.Big = Big;\r\n\r\n  //AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () { return Big; });\r\n\r\n  // Node and other CommonJS-like environments that support module.exports.\r\n  } else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Big;\r\n\r\n  //Browser.\r\n  } else {\r\n    GLOBAL.Big = Big;\r\n  }\r\n})(this);\r\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorArgs` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedArgs(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, undefined, source, [\n    position,\n  ]);\n}\n","/**\n * The set of allowed directive location values.\n */\nexport let DirectiveLocation;\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport let TokenKind;\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}"],"names":["module","exports","GLOBAL","Big","MAX_DP","MAX_POWER","NAME","INVALID","INVALID_DP","DIV_BY_ZERO","P","UNDEFINED","NUMERIC","round","x","sd","rm","more","xc","c","constructor","RM","Error","length","e","unshift","pop","stringify","doExponential","isNonzero","s","join","n","charAt","slice","abs","this","cmp","y","isneg","yc","i","j","k","l","div","a","b","dp","DP","bl","bt","ri","bz","ai","al","r","rl","q","qc","qi","p","push","shift","eq","gt","gte","lt","lte","minus","sub","t","xlty","plus","xe","ye","reverse","mod","ygtx","times","add","pow","one","prec","sqrt","half","Math","toExponential","indexOf","mul","Array","toFixed","toJSON","toString","NE","PE","toNumber","Number","strict","toPrecision","valueOf","_Big_","TypeError","String","nl","test","replace","search","substring","parse","prototype","roundDown","roundHalfUp","roundHalfEven","roundUp","define","_construct","Parent","args","Class","isNativeReflectConstruct","Reflect","construct","apply","instance","Function","bind","setPrototypeOf","arguments","_wrapNativeSuper","_cache","Map","undefined","fn","call","has","get","set","Wrapper","getPrototypeOf","Object","create","value","enumerable","writable","configurable","isObjectLike","invariant","condition","message","Boolean","LineRegExp","getLocation","source","position","lastLineStart","line","body","matchAll","match","index","column","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","name","lines","split","locationLine","subLineIndex","floor","subLineColumnNum","subLines","printPrefixedLines","map","subLine","existingLines","filter","padLen","max","prefix","toNormalizedArgs","firstArg","nodes","positions","path","originalError","extensions","GraphQLError","_this$nodes","_nodeLocations$","_ref","rawArgs","undefinedIfEmpty","isArray","nodeLocations","node","loc","locations","pos","originalExtensions","defineProperties","stack","defineProperty","captureStackTrace","output","formattedError","keys","Symbol","toStringTag","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","Token","lastToken","token","lineStart","lookahead","kind","next","nextToken","readNextToken","end","prev","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","fromCodePoint","toUpperCase","createToken","col","bodyLength","readComment","readBlockString","readString","isDigit","readNumber","isNameStart","readName","firstCode","isFloat","readDigits","chunkStart","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","dedentBlockStringLines","isNameContinue","Parser","options","sourceObj","isSource","Source","_lexer","_options","expectToken","Kind","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","operation","OperationTypeNode","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseName","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","parseList","parseObject","advance","parseStringLiteral","varName","block","values","any","fields","parseObjectField","parseDirective","innerType","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","delimitedMany","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","types","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseEnumValueName","getTokenDesc","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","hasOwnProperty","startToken","_this$_options2","noLocation","Location","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","isPunctuatorTokenKind","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","sourceKeySet","console","warn","parseDocument","cacheKey","parsed","doc","workSet","key","endToken","stripLoc","gql","literals","result","arg","gql_1","extras","clear","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","obj","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","done","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","resolve","reject","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","__proto__","awrap","async","Promise","iter","object","skipTempReset","stop","rootRecord","rval","exception","handle","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","globalThis","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","_taggedTemplateLiteral","strings","raw","freeze"],"sourceRoot":""}