{"version":3,"file":"static/js/807.45558b2c.chunk.js","mappings":"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","sources":["../node_modules/big.js/big.js","../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../node_modules/graphql-tag/src/index.ts"],"sourcesContent":["/*\r\n *  big.js v6.1.1\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2021 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */\r\n;(function (GLOBAL) {\r\n  'use strict';\r\n  var Big,\r\n\r\n\r\n/************************************** EDITABLE DEFAULTS *****************************************/\r\n\r\n\r\n    // The default values below must be integers within the stated ranges.\r\n\r\n    /*\r\n     * The maximum number of decimal places (DP) of the results of operations involving division:\r\n     * div and sqrt, and pow with negative exponents.\r\n     */\r\n    DP = 20,            // 0 to MAX_DP\r\n\r\n    /*\r\n     * The rounding mode (RM) used when rounding to the above decimal places.\r\n     *\r\n     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n     *  3  Away from zero.                                  (ROUND_UP)\r\n     */\r\n    RM = 1,             // 0, 1, 2 or 3\r\n\r\n    // The maximum value of DP and Big.DP.\r\n    MAX_DP = 1E6,       // 0 to 1000000\r\n\r\n    // The maximum magnitude of the exponent argument to the pow method.\r\n    MAX_POWER = 1E6,    // 1 to 1000000\r\n\r\n    /*\r\n     * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n     * (JavaScript numbers: -7)\r\n     * -1000000 is the minimum recommended exponent value of a Big.\r\n     */\r\n    NE = -7,            // 0 to -1000000\r\n\r\n    /*\r\n     * The positive exponent (PE) at and above which toString returns exponential notation.\r\n     * (JavaScript numbers: 21)\r\n     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n     */\r\n    PE = 21,            // 0 to 1000000\r\n\r\n    /*\r\n     * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n     * primitive number without a loss of precision.\r\n     */\r\n    STRICT = false,     // true or false\r\n\r\n\r\n/**************************************************************************************************/\r\n\r\n\r\n    // Error messages.\r\n    NAME = '[big.js] ',\r\n    INVALID = NAME + 'Invalid ',\r\n    INVALID_DP = INVALID + 'decimal places',\r\n    INVALID_RM = INVALID + 'rounding mode',\r\n    DIV_BY_ZERO = NAME + 'Division by zero',\r\n\r\n    // The shared prototype object.\r\n    P = {},\r\n    UNDEFINED = void 0,\r\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\r\n\r\n\r\n  /*\r\n   * Create and return a Big constructor.\r\n   */\r\n  function _Big_() {\r\n\r\n    /*\r\n     * The Big constructor and exported function.\r\n     * Create and return a new instance of a Big number object.\r\n     *\r\n     * n {number|string|Big} A numeric value.\r\n     */\r\n    function Big(n) {\r\n      var x = this;\r\n\r\n      // Enable constructor usage without new.\r\n      if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\r\n\r\n      // Duplicate.\r\n      if (n instanceof Big) {\r\n        x.s = n.s;\r\n        x.e = n.e;\r\n        x.c = n.c.slice();\r\n      } else {\r\n        if (typeof n !== 'string') {\r\n          if (Big.strict === true) {\r\n            throw TypeError(INVALID + 'number');\r\n          }\r\n\r\n          // Minus zero?\r\n          n = n === 0 && 1 / n < 0 ? '-0' : String(n);\r\n        }\r\n\r\n        parse(x, n);\r\n      }\r\n\r\n      // Retain a reference to this Big constructor.\r\n      // Shadow Big.prototype.constructor which points to Object.\r\n      x.constructor = Big;\r\n    }\r\n\r\n    Big.prototype = P;\r\n    Big.DP = DP;\r\n    Big.RM = RM;\r\n    Big.NE = NE;\r\n    Big.PE = PE;\r\n    Big.strict = STRICT;\r\n    Big.roundDown = 0;\r\n    Big.roundHalfUp = 1;\r\n    Big.roundHalfEven = 2;\r\n    Big.roundUp = 3;\r\n\r\n    return Big;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the number or string value passed to a Big constructor.\r\n   *\r\n   * x {Big} A Big number instance.\r\n   * n {number|string} A numeric value.\r\n   */\r\n  function parse(x, n) {\r\n    var e, i, nl;\r\n\r\n    if (!NUMERIC.test(n)) {\r\n      throw Error(INVALID + 'number');\r\n    }\r\n\r\n    // Determine sign.\r\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n    // Decimal point?\r\n    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = n.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +n.slice(i + 1);\r\n      n = n.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = n.length;\r\n    }\r\n\r\n    nl = n.length;\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\r\n\r\n    if (i == nl) {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    } else {\r\n\r\n      // Determine trailing zeros.\r\n      for (; nl > 0 && n.charAt(--nl) == '0';);\r\n      x.e = e - i - 1;\r\n      x.c = [];\r\n\r\n      // Convert string to array of digits without leading/trailing zeros.\r\n      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n   *\r\n   * x {Big} The Big to round.\r\n   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   * [more] {boolean} Whether the result of division was truncated.\r\n   */\r\n  function round(x, sd, rm, more) {\r\n    var xc = x.c;\r\n\r\n    if (rm === UNDEFINED) rm = x.constructor.RM;\r\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\r\n      throw Error(INVALID_RM);\r\n    }\r\n\r\n    if (sd < 1) {\r\n      more =\r\n        rm === 3 && (more || !!xc[0]) || sd === 0 && (\r\n        rm === 1 && xc[0] >= 5 ||\r\n        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\r\n      );\r\n\r\n      xc.length = 1;\r\n\r\n      if (more) {\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        x.e = x.e - sd + 1;\r\n        xc[0] = 1;\r\n      } else {\r\n\r\n        // Zero.\r\n        xc[0] = x.e = 0;\r\n      }\r\n    } else if (sd < xc.length) {\r\n\r\n      // xc[sd] is the digit after the digit that may be rounded up.\r\n      more =\r\n        rm === 1 && xc[sd] >= 5 ||\r\n        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\r\n          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\r\n        rm === 3 && (more || !!xc[0]);\r\n\r\n      // Remove any digits after the required precision.\r\n      xc.length = sd--;\r\n\r\n      // Round up?\r\n      if (more) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up.\r\n        for (; ++xc[sd] > 9;) {\r\n          xc[sd] = 0;\r\n          if (!sd--) {\r\n            ++x.e;\r\n            xc.unshift(1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (sd = xc.length; !xc[--sd];) xc.pop();\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of Big x in normal or exponential notation.\r\n   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n   */\r\n  function stringify(x, doExponential, isNonzero) {\r\n    var e = x.e,\r\n      s = x.c.join(''),\r\n      n = s.length;\r\n\r\n    // Exponential notation?\r\n    if (doExponential) {\r\n      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\r\n\r\n    // Normal notation.\r\n    } else if (e < 0) {\r\n      for (; ++e;) s = '0' + s;\r\n      s = '0.' + s;\r\n    } else if (e > 0) {\r\n      if (++e > n) {\r\n        for (e -= n; e--;) s += '0';\r\n      } else if (e < n) {\r\n        s = s.slice(0, e) + '.' + s.slice(e);\r\n      }\r\n    } else if (n > 1) {\r\n      s = s.charAt(0) + '.' + s.slice(1);\r\n    }\r\n\r\n    return x.s < 0 && isNonzero ? '-' + s : s;\r\n  }\r\n\r\n\r\n  // Prototype/instance methods\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the absolute value of this Big.\r\n   */\r\n  P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return 1 if the value of this Big is greater than the value of Big y,\r\n   *       -1 if the value of this Big is less than the value of Big y, or\r\n   *        0 if they have the same value.\r\n   */\r\n  P.cmp = function (y) {\r\n    var isneg,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new x.constructor(y)).c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    isneg = i < 0;\r\n\r\n    // Compare exponents.\r\n    if (k != l) return k > l ^ isneg ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = -1; ++i < j;) {\r\n      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.div = function (y) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      a = x.c,                  // dividend\r\n      b = (y = new Big(y)).c,   // divisor\r\n      k = x.s == y.s ? 1 : -1,\r\n      dp = Big.DP;\r\n\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n\r\n    // Divisor is zero?\r\n    if (!b[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    // Dividend is 0? Return +-0.\r\n    if (!a[0]) {\r\n      y.s = k;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    var bl, bt, n, cmp, ri,\r\n      bz = b.slice(),\r\n      ai = bl = b.length,\r\n      al = a.length,\r\n      r = a.slice(0, bl),   // remainder\r\n      rl = r.length,\r\n      q = y,                // quotient\r\n      qc = q.c = [],\r\n      qi = 0,\r\n      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\r\n\r\n    q.s = k;\r\n    k = p < 0 ? 0 : p;\r\n\r\n    // Create version of divisor with leading zero.\r\n    bz.unshift(0);\r\n\r\n    // Add zeros to make remainder as long as divisor.\r\n    for (; rl++ < bl;) r.push(0);\r\n\r\n    do {\r\n\r\n      // n is how many times the divisor goes into current remainder.\r\n      for (n = 0; n < 10; n++) {\r\n\r\n        // Compare divisor and remainder.\r\n        if (bl != (rl = r.length)) {\r\n          cmp = bl > rl ? 1 : -1;\r\n        } else {\r\n          for (ri = -1, cmp = 0; ++ri < bl;) {\r\n            if (b[ri] != r[ri]) {\r\n              cmp = b[ri] > r[ri] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // If divisor < remainder, subtract divisor from remainder.\r\n        if (cmp < 0) {\r\n\r\n          // Remainder can't be more than 1 digit longer than divisor.\r\n          // Equalise lengths using divisor with extra leading zero?\r\n          for (bt = rl == bl ? b : bz; rl;) {\r\n            if (r[--rl] < bt[rl]) {\r\n              ri = rl;\r\n              for (; ri && !r[--ri];) r[ri] = 9;\r\n              --r[ri];\r\n              r[rl] += 10;\r\n            }\r\n            r[rl] -= bt[rl];\r\n          }\r\n\r\n          for (; !r[0];) r.shift();\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Add the digit n to the result array.\r\n      qc[qi++] = cmp ? n : ++n;\r\n\r\n      // Update the remainder.\r\n      if (r[0] && cmp) r[rl] = a[ai] || 0;\r\n      else r = [a[ai]];\r\n\r\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\r\n\r\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n    if (!qc[0] && qi != 1) {\r\n\r\n      // There can't be more than one zero.\r\n      qc.shift();\r\n      q.e--;\r\n      p--;\r\n    }\r\n\r\n    // Round?\r\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\r\n\r\n    return q;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n   */\r\n  P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n   * false.\r\n   */\r\n  P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.gte = function (y) {\r\n    return this.cmp(y) > -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n   */\r\n  P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n   * return false.\r\n   */\r\n  P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var i, j, t, xlty,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xc = x.c.slice(),\r\n      xe = x.e,\r\n      yc = y.c,\r\n      ye = y.e;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (yc[0]) {\r\n        y.s = -b;\r\n      } else if (xc[0]) {\r\n        y = new Big(x);\r\n      } else {\r\n        y.s = 1;\r\n      }\r\n      return y;\r\n    }\r\n\r\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\r\n    if (a = xe - ye) {\r\n\r\n      if (xlty = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (b = a; b--;) t.push(0);\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = ((xlty = xc.length < yc.length) ? xc : yc).length;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n        if (xc[b] != yc[b]) {\r\n          xlty = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xlty) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    /*\r\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n     * needs to start at yc.length.\r\n     */\r\n    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\r\n\r\n    // Subtract yc from xc.\r\n    for (b = i; j > a;) {\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i];) xc[i] = 9;\r\n        --xc[i];\r\n        xc[j] += 10;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xc[--b] === 0;) xc.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] === 0;) {\r\n      xc.shift();\r\n      --ye;\r\n    }\r\n\r\n    if (!xc[0]) {\r\n\r\n      // n - n = +0\r\n      y.s = 1;\r\n\r\n      // Result must be zero.\r\n      xc = [ye = 0];\r\n    }\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n   */\r\n  P.mod = function (y) {\r\n    var ygtx,\r\n      x = this,\r\n      Big = x.constructor,\r\n      a = x.s,\r\n      b = (y = new Big(y)).s;\r\n\r\n    if (!y.c[0]) {\r\n      throw Error(DIV_BY_ZERO);\r\n    }\r\n\r\n    x.s = y.s = 1;\r\n    ygtx = y.cmp(x) == 1;\r\n    x.s = a;\r\n    y.s = b;\r\n\r\n    if (ygtx) return new Big(x);\r\n\r\n    a = Big.DP;\r\n    b = Big.RM;\r\n    Big.DP = Big.RM = 0;\r\n    x = x.div(y);\r\n    Big.DP = a;\r\n    Big.RM = b;\r\n\r\n    return this.minus(x.times(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var e, k, t,\r\n      x = this,\r\n      Big = x.constructor;\r\n\r\n    y = new Big(y);\r\n\r\n    // Signs differ?\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e,\r\n      xc = x.c,\r\n      ye = y.e,\r\n      yc = y.c;\r\n\r\n    // Either zero?\r\n    if (!xc[0] || !yc[0]) {\r\n      if (!yc[0]) {\r\n        if (xc[0]) {\r\n          y = new Big(x);\r\n        } else {\r\n          y.s = x.s;\r\n        }\r\n      }\r\n      return y;\r\n    }\r\n\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    // Note: reverse faster than unshifts.\r\n    if (e = xe - ye) {\r\n      if (e > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        e = -e;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; e--;) t.push(0);\r\n      t.reverse();\r\n    }\r\n\r\n    // Point xc to the longer array.\r\n    if (xc.length - yc.length < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n    }\r\n\r\n    e = yc.length;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\r\n    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n    if (k) {\r\n      xc.unshift(k);\r\n      ++ye;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (e = xc.length; xc[--e] === 0;) xc.pop();\r\n\r\n    y.c = xc;\r\n    y.e = ye;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a Big whose value is the value of this Big raised to the power n.\r\n   * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n   * mode Big.RM.\r\n   *\r\n   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n   */\r\n  P.pow = function (n) {\r\n    var x = this,\r\n      one = new x.constructor('1'),\r\n      y = one,\r\n      isneg = n < 0;\r\n\r\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n      throw Error(INVALID + 'exponent');\r\n    }\r\n\r\n    if (isneg) n = -n;\r\n\r\n    for (;;) {\r\n      if (n & 1) y = y.times(x);\r\n      n >>= 1;\r\n      if (!n) break;\r\n      x = x.times(x);\r\n    }\r\n\r\n    return isneg ? one.div(y) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n   * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.prec = function (sd, rm) {\r\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n      throw Error(INVALID + 'precision');\r\n    }\r\n    return round(new this.constructor(this), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n   * using rounding mode rm, or Big.RM if rm is not specified.\r\n   * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n   * If dp is not specified, round to 0 decimal places.\r\n   *\r\n   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.round = function (dp, rm) {\r\n    if (dp === UNDEFINED) dp = 0;\r\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    return round(new this.constructor(this), dp + this.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n   */\r\n  P.sqrt = function () {\r\n    var r, c, t,\r\n      x = this,\r\n      Big = x.constructor,\r\n      s = x.s,\r\n      e = x.e,\r\n      half = new Big('0.5');\r\n\r\n    // Zero?\r\n    if (!x.c[0]) return new Big(x);\r\n\r\n    // Negative?\r\n    if (s < 0) {\r\n      throw Error(NAME + 'No square root');\r\n    }\r\n\r\n    // Estimate.\r\n    s = Math.sqrt(x + '');\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\r\n    if (s === 0 || s === 1 / 0) {\r\n      c = x.c.join('');\r\n      if (!(c.length + e & 1)) c += '0';\r\n      s = Math.sqrt(c);\r\n      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\r\n    } else {\r\n      r = new Big(s + '');\r\n    }\r\n\r\n    e = r.e + (Big.DP += 4);\r\n\r\n    // Newton-Raphson iteration.\r\n    do {\r\n      t = r;\r\n      r = half.times(t.plus(x.div(t)));\r\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\r\n\r\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Big whose value is the value of this Big times the value of Big y.\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var c,\r\n      x = this,\r\n      Big = x.constructor,\r\n      xc = x.c,\r\n      yc = (y = new Big(y)).c,\r\n      a = xc.length,\r\n      b = yc.length,\r\n      i = x.e,\r\n      j = y.e;\r\n\r\n    // Determine sign of result.\r\n    y.s = x.s == y.s ? 1 : -1;\r\n\r\n    // Return signed 0 if either 0.\r\n    if (!xc[0] || !yc[0]) {\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // Initialise exponent of result as x.e + y.e.\r\n    y.e = i + j;\r\n\r\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n    if (a < b) {\r\n      c = xc;\r\n      xc = yc;\r\n      yc = c;\r\n      j = a;\r\n      a = b;\r\n      b = j;\r\n    }\r\n\r\n    // Initialise coefficient array of result with zeros.\r\n    for (c = new Array(j = a + b); j--;) c[j] = 0;\r\n\r\n    // Multiply.\r\n\r\n    // i is initially xc.length.\r\n    for (i = b; i--;) {\r\n      b = 0;\r\n\r\n      // a is yc.length.\r\n      for (j = a + i; j > i;) {\r\n\r\n        // Current sum of products at this digit position, plus carry.\r\n        b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n        c[j--] = b % 10;\r\n\r\n        // carry\r\n        b = b / 10 | 0;\r\n      }\r\n\r\n      c[j] = b;\r\n    }\r\n\r\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\r\n    if (b) ++y.e;\r\n    else c.shift();\r\n\r\n    // Remove trailing zeros.\r\n    for (i = c.length; !c[--i];) c.pop();\r\n    y.c = c;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), ++dp, rm);\r\n      for (; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, true, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n   *\r\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var x = this,\r\n      n = x.c[0];\r\n\r\n    if (dp !== UNDEFINED) {\r\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n        throw Error(INVALID_DP);\r\n      }\r\n      x = round(new x.constructor(x), dp + x.e + 1, rm);\r\n\r\n      // x.e may have changed if the value is rounded up.\r\n      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, false, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Omit the sign for negative zero.\r\n   */\r\n  P.toJSON = P.toString = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Big as a primitve number.\r\n   */\r\n  P.toNumber = function () {\r\n    var n = Number(stringify(this, true, true));\r\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\r\n      throw Error(NAME + 'Imprecise conversion');\r\n    }\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big rounded to sd significant digits using\r\n   * rounding mode rm, or Big.RM if rm is not specified.\r\n   * Use exponential notation if sd is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var x = this,\r\n      Big = x.constructor,\r\n      n = x.c[0];\r\n\r\n    if (sd !== UNDEFINED) {\r\n      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n        throw Error(INVALID + 'precision');\r\n      }\r\n      x = round(new Big(x), sd, rm);\r\n      for (; x.c.length < sd;) x.c.push(0);\r\n    }\r\n\r\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Big.\r\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n   * Include the sign for negative zero.\r\n   */\r\n  P.valueOf = function () {\r\n    var x = this,\r\n      Big = x.constructor;\r\n    if (Big.strict === true) {\r\n      throw Error(NAME + 'valueOf disallowed');\r\n    }\r\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\r\n  };\r\n\r\n\r\n  // Export\r\n\r\n\r\n  Big = _Big_();\r\n\r\n  Big['default'] = Big.Big = Big;\r\n\r\n  //AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function () { return Big; });\r\n\r\n  // Node and other CommonJS-like environments that support module.exports.\r\n  } else if (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = Big;\r\n\r\n  //Browser.\r\n  } else {\r\n    GLOBAL.Big = Big;\r\n  }\r\n})(this);\r\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorArgs` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedArgs(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, undefined, source, [\n    position,\n  ]);\n}\n","/**\n * The set of allowed directive location values.\n */\nexport let DirectiveLocation;\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport let TokenKind;\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n"],"names":["GLOBAL","Big","MAX_DP","MAX_POWER","NAME","INVALID","INVALID_DP","DIV_BY_ZERO","P","UNDEFINED","NUMERIC","round","x","sd","rm","more","xc","c","constructor","RM","Error","length","e","unshift","pop","stringify","doExponential","isNonzero","s","join","n","charAt","slice","abs","this","cmp","y","isneg","yc","i","j","k","l","div","a","b","dp","DP","bl","bt","ri","bz","ai","al","r","rl","q","qc","qi","p","push","shift","eq","gt","gte","lt","lte","minus","sub","t","xlty","plus","xe","ye","reverse","mod","ygtx","times","add","pow","one","prec","sqrt","half","Math","toExponential","indexOf","mul","Array","toFixed","toJSON","toString","NE","PE","toNumber","Number","strict","toPrecision","valueOf","_Big_","TypeError","String","nl","test","replace","search","substring","parse","prototype","roundDown","roundHalfUp","roundHalfEven","roundUp","define","invariant","condition","message","Boolean","LineRegExp","getLocation","source","position","lastLineStart","line","match","body","matchAll","index","column","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","name","lines","split","locationLine","subLineIndex","floor","subLineColumnNum","subLines","printPrefixedLines","map","subLine","existingLines","filter","_","undefined","padLen","max","prefix","GraphQLError","_this$nodes","_nodeLocations$","_ref","rawArgs","nodes","positions","path","originalError","extensions","args","firstArg","toNormalizedArgs","super","undefinedIfEmpty","isArray","nodeLocations","node","loc","start","locations","pos","originalExtensions","value","Object","create","defineProperties","writable","enumerable","stack","defineProperty","configurable","captureStackTrace","toStringTag","Symbol","output","location","formattedError","keys","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","Token","lastToken","token","lineStart","advance","lookahead","kind","next","nextToken","readNextToken","end","prev","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","fromCodePoint","toUpperCase","createToken","col","bodyLength","readComment","readBlockString","readString","isDigit","readNumber","isNameStart","readName","firstCode","isFloat","readDigits","chunkStart","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","dedentBlockStringLines","isNameContinue","Parser","options","sourceObj","isSource","Source","_lexer","_options","parseName","expectToken","Kind","parseDocument","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","operation","OperationTypeNode","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","selections","parseSelection","parseFragment","parseField","nameOrAlias","alias","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","parseList","parseObject","parseStringLiteral","varName","block","values","any","fields","parseObjectField","parseDirective","innerType","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","delimitedMany","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","types","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseEnumValueName","getTokenDesc","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","hasOwnProperty","call","startToken","_this$_options2","noLocation","Location","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","isPunctuatorTokenKind","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","sourceKeySet","get","has","console","warn","set","cacheKey","parsed","doc","workSet","key","endToken","stripLoc","gql","literals","result","arg","gql_1","extras","clear"],"sourceRoot":""}